{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"documentation/collections/","text":"Collections \u00b6 Support of fake collections has been added to Datafaker since version 1.2.0. For example, the following code will generate a list of first and last names with number of elements in it between 3 and 5: Java List < String > names = faker . collection ( () -> faker . name (). firstName (), () -> faker . name (). lastName ()) . len ( 3 , 5 ) . generate (); A list can also contain different types: Java List < Object > objects = faker . < Object > collection ( () -> faker . name (). firstName (), () -> faker . random (). nextInt ( 100 )) . maxLen ( 5 ) . generate (); With usage of nullRate it is possible to specify how often it should contain null values. By default, it's value is 0, i.e. no null values will be generated. Java List < Object > objects = faker . < Object > collection ( () -> faker . name (). firstName (), () -> faker . random (). nextInt ( 100 )) . nullRate ( 1 ) . maxLen ( 5 ) . generate (); will generate a collection where every value is null. And to generate a collection with only about 30% values of null nullRate(0.3) will do it Java List < Object > objects = faker . < Object > collection ( () -> faker . name (). firstName (), () -> faker . random (). nextInt ( 100 )) . nullRate ( 0.3 ) . maxLen ( 5 ) . generate ();","title":"Collections"},{"location":"documentation/collections/#collections","text":"Support of fake collections has been added to Datafaker since version 1.2.0. For example, the following code will generate a list of first and last names with number of elements in it between 3 and 5: Java List < String > names = faker . collection ( () -> faker . name (). firstName (), () -> faker . name (). lastName ()) . len ( 3 , 5 ) . generate (); A list can also contain different types: Java List < Object > objects = faker . < Object > collection ( () -> faker . name (). firstName (), () -> faker . random (). nextInt ( 100 )) . maxLen ( 5 ) . generate (); With usage of nullRate it is possible to specify how often it should contain null values. By default, it's value is 0, i.e. no null values will be generated. Java List < Object > objects = faker . < Object > collection ( () -> faker . name (). firstName (), () -> faker . random (). nextInt ( 100 )) . nullRate ( 1 ) . maxLen ( 5 ) . generate (); will generate a collection where every value is null. And to generate a collection with only about 30% values of null nullRate(0.3) will do it Java List < Object > objects = faker . < Object > collection ( () -> faker . name (). firstName (), () -> faker . random (). nextInt ( 100 )) . nullRate ( 0.3 ) . maxLen ( 5 ) . generate ();","title":"Collections"},{"location":"documentation/contributing/","text":"First and foremost thanks to anyone who contributes, very much appreciated. Guidelines \u00b6 If you add new faker classes like Address , Country , and Number they should be accompanied by a unit test. Where relevant please add more assertions to the net.datafaker.FakerIT class. If you add a new faker class, update the README.md . Submit a PR with your change and if there are no comments, changes will be merged in If you're not sure about the change, raise an issue and have a discussion before spending time coding it up Try and make one logical change per PR. That is not make many changes in one PR. Submit multiple PRs instead Java 8 is our target version. If you need anything older than that, we recommend using Java Faker instead. Building \u00b6 Should be as easy as running mvn clean install on the root directory","title":"Contributing"},{"location":"documentation/contributing/#guidelines","text":"If you add new faker classes like Address , Country , and Number they should be accompanied by a unit test. Where relevant please add more assertions to the net.datafaker.FakerIT class. If you add a new faker class, update the README.md . Submit a PR with your change and if there are no comments, changes will be merged in If you're not sure about the change, raise an issue and have a discussion before spending time coding it up Try and make one logical change per PR. That is not make many changes in one PR. Submit multiple PRs instead Java 8 is our target version. If you need anything older than that, we recommend using Java Faker instead.","title":"Guidelines"},{"location":"documentation/contributing/#building","text":"Should be as easy as running mvn clean install on the root directory","title":"Building"},{"location":"documentation/custom-providers/","text":"Custom providers \u00b6 Since version 1.2.0 of Datafaker it's possible create your own provider of data. A full example can be found in the source code. Custom hardcoded provider \u00b6 To create a custom provider of data, you'll need to do the following steps: Create custom provider of data Create your own custom faker which extends Faker and register custom provider In code, this would look like the following: Hardcoded provider \u00b6 Create a custom provider of data: Java public static class Insect { private static final String [] INSECT_NAMES = new String [] { \"Ant\" , \"Beetle\" , \"Butterfly\" , \"Wasp\" }; private final Faker faker ; public Insect ( Faker faker ) { this . faker = faker ; } public String nextInsectName () { return INSECT_NAMES [ faker . random (). nextInt ( INSECT_NAMES . length ) ] ; } } Register provider \u00b6 Create your own custom faker, which extends Faker , and register the custom provider: Java public static class MyCustomFaker extends Faker { public Insect insect () { return getProvider ( Insect . class , () -> new Insect ( this )); } } Usage \u00b6 To use the custom faker, you can do the following: Java MyCustomFaker myFaker = new MyCustomFaker (); System . out . println ( myFaker . insect (). nextInsectName ()); This will print something like the following: Wasp Custom provider using Yaml file \u00b6 In case you have a large set of data to load, it might be better to use a Yaml file. To create a custom provider of data fom a file, you'll need to do the following steps: Create a custom provider of data Create your own custom faker which extends Faker and register custom provider Yaml provider \u00b6 First, create the custom provider which loads the data from a file: Java public static class InsectFromFile { private static final String KEY = \"insectsfromfile\" ; private final Faker faker ; public InsectFromFile ( Faker faker ) { this . faker = faker ; faker . addPath ( Locale . ENGLISH , Paths . get ( \"src/test/ants.yml\" )); faker . addPath ( Locale . ENGLISH , Paths . get ( \"src/test/bees.yml\" )); } public String ant () { return faker . fakeValuesService (). resolve ( KEY + \".ants\" , null , faker ); } public String bee () { return faker . fakeValuesService (). resolve ( KEY + \".bees\" , null , faker ); } } The ants.yml would look like the following: en : faker : insectsfromfile : ants : [ 'Driver ant' , 'Fire ant' , 'Harvester ant' , 'Honey ant' , 'Leafcutter ant' , 'Sahara desert ant' ] And if you want to use multiple YAML files, the bees.yml would look like this: en : faker : insectsfromfile : bees : [ 'Bumblebee' , 'Euglossine bee' , 'Honeybee' , 'Carpenter bee' , 'Leaf-cutter bee' , 'Mining bee' ] Register provider \u00b6 Registering the provider would happen like this: Java public static class MyCustomFaker extends Faker { public InsectFromFile insectFromFile () { return getProvider ( InsectFromFile . class , () -> new InsectFromFile ( this )); } } Usage \u00b6 To use the custom faker, you can do the following: Java MyCustomFaker myFaker = new MyCustomFaker (); System . out . println ( myFaker . insectFromFile (). ant ()); This will print something like the following: Honey ant","title":"Custom providers"},{"location":"documentation/custom-providers/#custom-providers","text":"Since version 1.2.0 of Datafaker it's possible create your own provider of data. A full example can be found in the source code.","title":"Custom providers"},{"location":"documentation/custom-providers/#custom-hardcoded-provider","text":"To create a custom provider of data, you'll need to do the following steps: Create custom provider of data Create your own custom faker which extends Faker and register custom provider In code, this would look like the following:","title":"Custom hardcoded provider"},{"location":"documentation/custom-providers/#hardcoded-provider","text":"Create a custom provider of data: Java public static class Insect { private static final String [] INSECT_NAMES = new String [] { \"Ant\" , \"Beetle\" , \"Butterfly\" , \"Wasp\" }; private final Faker faker ; public Insect ( Faker faker ) { this . faker = faker ; } public String nextInsectName () { return INSECT_NAMES [ faker . random (). nextInt ( INSECT_NAMES . length ) ] ; } }","title":"Hardcoded provider"},{"location":"documentation/custom-providers/#register-provider","text":"Create your own custom faker, which extends Faker , and register the custom provider: Java public static class MyCustomFaker extends Faker { public Insect insect () { return getProvider ( Insect . class , () -> new Insect ( this )); } }","title":"Register provider"},{"location":"documentation/custom-providers/#usage","text":"To use the custom faker, you can do the following: Java MyCustomFaker myFaker = new MyCustomFaker (); System . out . println ( myFaker . insect (). nextInsectName ()); This will print something like the following: Wasp","title":"Usage"},{"location":"documentation/custom-providers/#custom-provider-using-yaml-file","text":"In case you have a large set of data to load, it might be better to use a Yaml file. To create a custom provider of data fom a file, you'll need to do the following steps: Create a custom provider of data Create your own custom faker which extends Faker and register custom provider","title":"Custom provider using Yaml file"},{"location":"documentation/custom-providers/#yaml-provider","text":"First, create the custom provider which loads the data from a file: Java public static class InsectFromFile { private static final String KEY = \"insectsfromfile\" ; private final Faker faker ; public InsectFromFile ( Faker faker ) { this . faker = faker ; faker . addPath ( Locale . ENGLISH , Paths . get ( \"src/test/ants.yml\" )); faker . addPath ( Locale . ENGLISH , Paths . get ( \"src/test/bees.yml\" )); } public String ant () { return faker . fakeValuesService (). resolve ( KEY + \".ants\" , null , faker ); } public String bee () { return faker . fakeValuesService (). resolve ( KEY + \".bees\" , null , faker ); } } The ants.yml would look like the following: en : faker : insectsfromfile : ants : [ 'Driver ant' , 'Fire ant' , 'Harvester ant' , 'Honey ant' , 'Leafcutter ant' , 'Sahara desert ant' ] And if you want to use multiple YAML files, the bees.yml would look like this: en : faker : insectsfromfile : bees : [ 'Bumblebee' , 'Euglossine bee' , 'Honeybee' , 'Carpenter bee' , 'Leaf-cutter bee' , 'Mining bee' ]","title":"Yaml provider"},{"location":"documentation/custom-providers/#register-provider_1","text":"Registering the provider would happen like this: Java public static class MyCustomFaker extends Faker { public InsectFromFile insectFromFile () { return getProvider ( InsectFromFile . class , () -> new InsectFromFile ( this )); } }","title":"Register provider"},{"location":"documentation/custom-providers/#usage_1","text":"To use the custom faker, you can do the following: Java MyCustomFaker myFaker = new MyCustomFaker (); System . out . println ( myFaker . insectFromFile (). ant ()); This will print something like the following: Honey ant","title":"Usage"},{"location":"documentation/date-format/","text":"Date formats \u00b6 Since 1.2.0 Datafaker supports specifying of date formats for dates and timestamps. Java Faker faker = new Faker (); System . out . println ( faker . date (). future ( 1 , TimeUnit . HOURS , \"YYYY MM.dd mm:hh:ss\" ); System . out . println ( faker . date (). past ( 1 , TimeUnit . HOURS , \"YYYY-MM-dd mm:hh:ss\" ); System . out . println ( faker . date (). birthday ( 1 , 99 , \"YYYY/MM/dd\" ); And also this feature could be used in expressions like Java faker . expression ( \"#{date.past '15','SECONDS','dd/MM/yyyy hh:mm:ss'}\" ) List of available time units: Name Time unit Since NANO NANOSECOND 1.2.0 NANOS NANOSECOND 1.2.0 MICRO MICROSECOND 1.2.0 MICROS MICROSECOND 1.2.0 MILLI MILLISECOND 1.2.0 MILLIS MILLISECOND 1.2.0 SECOND SECOND 1.2.0 SECONDS SECOND 1.2.0 MINUTE MINUTE 1.2.0 MINUTES MINUTE 1.2.0 HOUR HOUR 1.2.0 HOURS HOUR 1.2.0 DAY DAY 1.2.0 DAYS DAY 1.2.0","title":"Date format"},{"location":"documentation/date-format/#date-formats","text":"Since 1.2.0 Datafaker supports specifying of date formats for dates and timestamps. Java Faker faker = new Faker (); System . out . println ( faker . date (). future ( 1 , TimeUnit . HOURS , \"YYYY MM.dd mm:hh:ss\" ); System . out . println ( faker . date (). past ( 1 , TimeUnit . HOURS , \"YYYY-MM-dd mm:hh:ss\" ); System . out . println ( faker . date (). birthday ( 1 , 99 , \"YYYY/MM/dd\" ); And also this feature could be used in expressions like Java faker . expression ( \"#{date.past '15','SECONDS','dd/MM/yyyy hh:mm:ss'}\" ) List of available time units: Name Time unit Since NANO NANOSECOND 1.2.0 NANOS NANOSECOND 1.2.0 MICRO MICROSECOND 1.2.0 MICROS MICROSECOND 1.2.0 MILLI MILLISECOND 1.2.0 MILLIS MILLISECOND 1.2.0 SECOND SECOND 1.2.0 SECONDS SECOND 1.2.0 MINUTE MINUTE 1.2.0 MINUTES MINUTE 1.2.0 HOUR HOUR 1.2.0 HOURS HOUR 1.2.0 DAY DAY 1.2.0 DAYS DAY 1.2.0","title":"Date formats"},{"location":"documentation/expressions/","text":"Expressions \u00b6 Datafaker supports different kind of expressions which allows to customise the output. Letterify \u00b6 This one will replace ? symbols with latin letters e.g. Faker faker = new Faker (); faker . expression ( \"#{letterify 'test????test'}\" ); // could give e.g. testqwastest // Also there could a third argument telling if characters should be uppercase faker . expression ( \"#{letterify 'test????test','true'}\" ); // could give e.g. testSKDLtest Numerify \u00b6 This one will replace # symbols with digits e.g. Faker faker = new Faker (); faker . expression ( \"#{numerify '#test#'}\" ); // could give e.g. 3test5 faker . expression ( \"#{numerify '####'}\" ); // could give e.g. 1234 Bothify \u00b6 Applies both letterify and numerify e.g. Faker faker = new Faker (); faker . expression ( \"#{bothify '?#?#?#?#'}\" ); // could give a1b2c3d4 faker . expression ( \"#{bothify '?#?#?#?#', true}\" ); // could give A1B2C3D4 Templatify \u00b6 This is available since 1.2.0 This one will replace symbol mentioned in the second args with one of symbols mentioned after it. Faker faker = new Faker (); // e.g. there is expression test and we want to replace t with q or @ faker . expression ( \"#{templatify 'test','t','q','@'}\" ); // could give @esq // another example there is expression test and we want to replace t with q or @ or $ or * faker . expression ( \"#{templatify 'test','t','q','@','$','*'}\" ); // could give @esq Examplify \u00b6 This one will replace symbols by example: uppercase with uppercase, digit with digit, lowercase with lowercase. Faker faker = new Faker (); faker . expression ( \"#{examplify 'ABC'}\" ); // could give QWE faker . expression ( \"#{examplify 'test'}\" ); // could give ghjk Regexify \u00b6 This one allows generating output based on regexp, e.g. Faker faker = new Faker (); faker . expression ( \"#{regexify '(a|b){2,3}'}\" ); // could give ab faker . regexify ( \"[a-z]{4,10}\" ); // could give wbevoa Options \u00b6 This is available since 1.2.0 This will return one from the provided options e.g. Faker faker = new Faker (); faker . expression ( \"#{options.option 'ABC','2','5','$'}\" ); // could give $ faker . expression ( \"#{options.option '23','2','5','$','%','*'}\" ); // could give * Csv \u00b6 This is available since 1.4.0 The expression will return generated csv based on input parameters faker . expression ( \"#{csv '1','name_column','#{Name.first_name}','last_name_column','#{Name.last_name}'}\" ); // \"name_column\",\"last_name_column\" // \"Sabrina\",\"Kihn\" faker . expression ( \"#{csv ' ### ','\" ',' false ',' 3 ',' name_column ',' # { Name . first_name } ',' last_name_column ',' # { Name . last_name } ' } \"); // \" Thad \" ### \" Crist \" // \" Kathryne \" ### \" Wuckert \" // \" Sybil \" ### \" Connelly \" Json \u00b6 This is available since 1.4.0 The expression will return generated csv based on input parameters faker . expression ( \"#{json 'person','#{json ''first_name'',''#{Name.first_name}'',''last_name'',''#{Name.last_name}''}','address','#{json ''country'',''#{Address.country}'',''city'',''#{Address.city}''}'}\" ); // {\"person\": {\"first_name\": \"Barbie\", \"last_name\": \"Durgan\"}, \"address\": {\"country\": \"Albania\", \"city\": \"East Catarinahaven\"}} Others \u00b6 It is possible to call methods returning string values and taking primitive or string args via expressions e.g. Faker faker = new Faker (); faker . expression ( \"#{date.birthday 'yy DDD hh:mm:ss'}\" ); faker . expression ( \"#{color.name}\" );","title":"Expressions"},{"location":"documentation/expressions/#expressions","text":"Datafaker supports different kind of expressions which allows to customise the output.","title":"Expressions"},{"location":"documentation/expressions/#letterify","text":"This one will replace ? symbols with latin letters e.g. Faker faker = new Faker (); faker . expression ( \"#{letterify 'test????test'}\" ); // could give e.g. testqwastest // Also there could a third argument telling if characters should be uppercase faker . expression ( \"#{letterify 'test????test','true'}\" ); // could give e.g. testSKDLtest","title":"Letterify"},{"location":"documentation/expressions/#numerify","text":"This one will replace # symbols with digits e.g. Faker faker = new Faker (); faker . expression ( \"#{numerify '#test#'}\" ); // could give e.g. 3test5 faker . expression ( \"#{numerify '####'}\" ); // could give e.g. 1234","title":"Numerify"},{"location":"documentation/expressions/#bothify","text":"Applies both letterify and numerify e.g. Faker faker = new Faker (); faker . expression ( \"#{bothify '?#?#?#?#'}\" ); // could give a1b2c3d4 faker . expression ( \"#{bothify '?#?#?#?#', true}\" ); // could give A1B2C3D4","title":"Bothify"},{"location":"documentation/expressions/#templatify","text":"This is available since 1.2.0 This one will replace symbol mentioned in the second args with one of symbols mentioned after it. Faker faker = new Faker (); // e.g. there is expression test and we want to replace t with q or @ faker . expression ( \"#{templatify 'test','t','q','@'}\" ); // could give @esq // another example there is expression test and we want to replace t with q or @ or $ or * faker . expression ( \"#{templatify 'test','t','q','@','$','*'}\" ); // could give @esq","title":"Templatify"},{"location":"documentation/expressions/#examplify","text":"This one will replace symbols by example: uppercase with uppercase, digit with digit, lowercase with lowercase. Faker faker = new Faker (); faker . expression ( \"#{examplify 'ABC'}\" ); // could give QWE faker . expression ( \"#{examplify 'test'}\" ); // could give ghjk","title":"Examplify"},{"location":"documentation/expressions/#regexify","text":"This one allows generating output based on regexp, e.g. Faker faker = new Faker (); faker . expression ( \"#{regexify '(a|b){2,3}'}\" ); // could give ab faker . regexify ( \"[a-z]{4,10}\" ); // could give wbevoa","title":"Regexify"},{"location":"documentation/expressions/#options","text":"This is available since 1.2.0 This will return one from the provided options e.g. Faker faker = new Faker (); faker . expression ( \"#{options.option 'ABC','2','5','$'}\" ); // could give $ faker . expression ( \"#{options.option '23','2','5','$','%','*'}\" ); // could give *","title":"Options"},{"location":"documentation/expressions/#csv","text":"This is available since 1.4.0 The expression will return generated csv based on input parameters faker . expression ( \"#{csv '1','name_column','#{Name.first_name}','last_name_column','#{Name.last_name}'}\" ); // \"name_column\",\"last_name_column\" // \"Sabrina\",\"Kihn\" faker . expression ( \"#{csv ' ### ','\" ',' false ',' 3 ',' name_column ',' # { Name . first_name } ',' last_name_column ',' # { Name . last_name } ' } \"); // \" Thad \" ### \" Crist \" // \" Kathryne \" ### \" Wuckert \" // \" Sybil \" ### \" Connelly \"","title":"Csv"},{"location":"documentation/expressions/#json","text":"This is available since 1.4.0 The expression will return generated csv based on input parameters faker . expression ( \"#{json 'person','#{json ''first_name'',''#{Name.first_name}'',''last_name'',''#{Name.last_name}''}','address','#{json ''country'',''#{Address.country}'',''city'',''#{Address.city}''}'}\" ); // {\"person\": {\"first_name\": \"Barbie\", \"last_name\": \"Durgan\"}, \"address\": {\"country\": \"Albania\", \"city\": \"East Catarinahaven\"}}","title":"Json"},{"location":"documentation/expressions/#others","text":"It is possible to call methods returning string values and taking primitive or string args via expressions e.g. Faker faker = new Faker (); faker . expression ( \"#{date.birthday 'yy DDD hh:mm:ss'}\" ); faker . expression ( \"#{color.name}\" );","title":"Others"},{"location":"documentation/file-formats/","text":"File formats \u00b6 Since version 1.2.0 of Datafaker it's possible to export generated data to a file format of your choice. The currently support file formats are: CSV JSON YAML XML CSV \u00b6 Using the CSV generation, it's possible to do the following: the number and names of columns could be specified the separator and quotes could be specified with separator() and quote() the number of lines could be specified via limit() with or without header also could be specified with header() An example can be found below: Java System . out . println ( Format . toCsv ( Csv . Column . of ( \"first_name\" , () -> faker . name (). firstName ()), Csv . Column . of ( \"last_name\" , () -> faker . name (). lastName ()), Csv . Column . of ( \"address\" , () -> faker . address (). streetAddress ())) . header ( true ) . separator ( \" ; \" ) . limit ( 5 ). build (). get ()); Executing the above will result in something similar to the below: \"first_name\" ; \"last_name\" ; \"address\" \"Jonah\" ; \"Kovacek\" ; \"009 Wilkinson Summit\" \"John\" ; \"Murphy\" ; \"379 McCullough Locks\" \"Colby\" ; \"Bins\" ; \"93534 Stevie Gardens\" \"Wade\" ; \"Herzog\" ; \"83108 Willy Road\" \"Marg\" ; \"Effertz\" ; \"415 Gene Plaza\" JSON \u00b6 It's also possible to generate JSON output: Java Faker faker = new Faker (); String json = Format . toJson ( faker . collection ( faker :: name ) . len ( 2 ) . build ()) . set ( \"firstName\" , Name :: firstName ) . set ( \"lastName\" , Name :: lastName ) . set ( \"address\" , Format . toJson ( faker . collection ( faker :: address ) . len ( 1 ) . build ()) . set ( \"country\" , Address :: country ) . set ( \"city\" , Address :: city ) . set ( \"zipcode\" , Address :: zipCode ) . set ( \"streetAddress\" , Address :: streetAddress ) . build ()) . set ( \"phones\" , name -> faker . collection (() -> faker . phoneNumber (). phoneNumber ()). maxLen ( 3 ). build (). get ()) . build () . generate (); System . out . println ( json ); This will produce something similar to the following: [{ \"firstName\" : \"Azucena\" , \"lastName\" : \"Block\" , \"address\" : [{ \"country\" : \"Micronesia\" , \"city\" : \"Ralphberg\" , \"zipcode\" : \"03792\" , \"streetAddress\" : \"522 Detra Motorway\" }], \"phones\" : [ \"885.387.7538 x3339\" , \"673-179-8684 x7840\" , \"512-510-3469 x47468\" ]}, { \"firstName\" : \"Hollis\" , \"lastName\" : \"Conroy\" , \"address\" : [{ \"country\" : \"Anguilla\" , \"city\" : \"Murrayshire\" , \"zipcode\" : \"96973\" , \"streetAddress\" : \"84545 Carolyne Hills\" }], \"phones\" : [ \"133.943.3781 x16122\" , \"797.830.4970 x310\" , \"(599) 214-5520 x920\" ]}] Another example with json payload Java Faker faker = new Faker (); String json = Format . toJson ( faker . collection ( faker :: name ). faker ( faker ) . len ( 2 ) . build ()) . set ( \"firstName\" , Name :: firstName ) . set ( \"lastName\" , Name :: lastName ) . set ( \"payload\" , payload -> Format . toJson ( faker . collection ( faker :: address ) . len ( 1 ) . build ()) . set ( \"country\" , Address :: country ) . set ( \"city\" , Address :: city ) . set ( \"zipcode\" , Address :: zipCode ) . set ( \"streetAddress\" , Address :: streetAddress ) . build (). generate ()) . set ( \"phones\" , name -> faker . collection (() -> faker . phoneNumber (). phoneNumber ()). maxLen ( 3 ). build (). get ()) . build () . generate (); System . out . println ( json ); This will produce json with escaped json payload e.g.: [{ \"firstName\" : \"Rey\" , \"lastName\" : \"Hilpert\" , \"payload\" : \"[{\\\"country\\\": \\\"Vanuatu\\\", \\\"city\\\": \\\"Douglasborough\\\", \\\"zipcode\\\": \\\"78956\\\", \\\"streetAddress\\\": \\\"15586 DuBuque Circles\\\"}]\" , \"phones\" : [ \"(739) 078-6320\" , \"(530) 089-9967 x167\" , \"422.892.6273 x46644\" ]}, { \"firstName\" : \"Timmy\" , \"lastName\" : \"Lakin\" , \"payload\" : \"[{\\\"country\\\": \\\"Chile\\\", \\\"city\\\": \\\"East Frederick\\\", \\\"zipcode\\\": \\\"07470\\\", \\\"streetAddress\\\": \\\"425 Hackett Tunnel\\\"}]\" , \"phones\" : [ \"416.215.9044\" , \"700.631.9476\" , \"1-521-484-1096\" ]}] YAML \u00b6 A lightweight YAML generator is now built into Datafaker. The following is an example on how to use it: Java Faker faker = new Faker (); Map < Supplier < String > , Supplier < Object >> map = new LinkedHashMap <> (); Map < Supplier < String > , Supplier < Object >> address = new LinkedHashMap <> (); Map < Supplier < String > , Supplier < Object >> phones = new LinkedHashMap <> (); phones . put (() -> \"worknumbers\" , () -> faker . < String > collection (). suppliers (() -> faker . phoneNumber (). phoneNumber ()). maxLen ( 2 ). build (). get ()); phones . put (() -> \"cellphones\" , () -> faker . < String > collection (). suppliers (() -> faker . phoneNumber (). cellPhone ()). maxLen ( 3 ). build (). get ()); address . put (() -> \"city\" , () -> faker . address (). city ()); address . put (() -> \"country\" , () -> faker . address (). country ()); address . put (() -> \"streetAddress\" , () -> faker . address (). streetAddress ()); map . put (() -> \"name\" , () -> faker . name (). firstName ()); map . put (() -> \"lastname\" , () -> faker . name (). lastName ()); map . put (() -> \"address\" , () -> address ); map . put (() -> \"phones\" , () -> phones ); Yaml yaml = new Yaml ( map ); System . out . println ( yaml . generate ()); XML \u00b6 Elements and attributes \u00b6 In case you want to generate XML, Datafaker provides a facility to build XML elements and attributes using randomly generated data in the following way: Java public static void main ( String [] args ) { Faker faker = new Faker (); Collection < Xml . XmlNode > address = faker . < Xml . XmlNode > collection () . suppliers (() -> new Xml . XmlNode ( \"address\" , map ( entry ( \"country\" , faker . address (). country ()), entry ( \"city\" , faker . address (). city ()), entry ( \"streetAddress\" , faker . address (). streetAddress ())), Collections . emptyList ())) . maxLen ( 3 ). build (). get (); Collection < Xml . XmlNode > persons = faker . < Xml . XmlNode > collection () . suppliers (() -> new Xml . XmlNode ( \"person\" , map ( entry ( \"firstname\" , faker . name (). firstName ()), entry ( \"lastname\" , faker . name (). lastName ())), of ( new Xml . XmlNode ( \"addresses\" , address )))). maxLen ( 3 ). build (). get (); String str = new Xml ( new Xml . XmlNode ( \"persons\" , persons )). generate ( true ); System . out . println ( str ); } private static < T > Collection < T > of ( T ... elems ) { return Arrays . asList ( elems ); } private static Map . Entry < String , String > entry ( String key , String value ) { return new AbstractMap . SimpleEntry <> ( key , value ); } private static Map < String , String > map ( Map . Entry < String , String > ... entries ) { Map < String , String > map = new LinkedHashMap <> (); for ( Map . Entry < String , String > entry : entries ) { map . put ( entry . getKey (), entry . getValue ()); } return map ; } This will produce the following output: <persons> <person firstname= \"Chuck\" lastname= \"Rice\" > <addresses> <address country= \"Croatia\" city= \"South Stacimouth\" streetAddress= \"8958 Ervin Stravenue\" /> <address country= \"Uruguay\" city= \"South Cariefort\" streetAddress= \"59014 Howell Pike\" /> <address country= \"Bahrain\" city= \"New Ian\" streetAddress= \"446 Wuckert Brooks\" /> </addresses> </person> <person firstname= \"Brent\" lastname= \"Walter\" > <addresses> <address country= \"Croatia\" city= \"South Stacimouth\" streetAddress= \"8958 Ervin Stravenue\" /> <address country= \"Uruguay\" city= \"South Cariefort\" streetAddress= \"59014 Howell Pike\" /> <address country= \"Bahrain\" city= \"New Ian\" streetAddress= \"446 Wuckert Brooks\" /> </addresses> </person> <person firstname= \"Amy\" lastname= \"Parisian\" > <addresses> <address country= \"Croatia\" city= \"South Stacimouth\" streetAddress= \"8958 Ervin Stravenue\" /> <address country= \"Uruguay\" city= \"South Cariefort\" streetAddress= \"59014 Howell Pike\" /> <address country= \"Bahrain\" city= \"New Ian\" streetAddress= \"446 Wuckert Brooks\" /> </addresses> </person> </persons> Elements only \u00b6 In case you only want to generate XML elements, without any attributes, that possible too: Java Faker faker = new Faker (); Collection < Xml . XmlNode > address = faker . < Xml . XmlNode > collection () . suppliers (() -> new Xml . XmlNode ( \"address\" , of ( new Xml . XmlNode ( \"country\" , faker . address (). country ()), new Xml . XmlNode ( \"city\" , faker . address (). city ()), new Xml . XmlNode ( \"streetAddress\" , faker . address (). streetAddress ())))) . maxLen ( 4 ). build (). get (); Collection < Xml . XmlNode > persons = faker . < Xml . XmlNode > collection () . suppliers (() -> new Xml . XmlNode ( \"person\" , of ( new Xml . XmlNode ( \"firstname\" , faker . name (). firstName ()), new Xml . XmlNode ( \"lastname\" , faker . name (). lastName ()), new Xml . XmlNode ( \"addresses\" , address )))). maxLen ( 2 ). build (). get (); String str = new Xml ( new Xml . XmlNode ( \"persons\" , persons )). generate ( true ); System . out . println ( str ); Executing the above will result in: <persons> <person> <firstname> Shiloh </firstname> <lastname> Witting </lastname> <addresses> <address> <country> Azerbaijan </country> <city> Port Alta </city> <streetAddress> 50808 Rickey Plains </streetAddress> </address> <address> <country> Congo </country> <city> North Eleonoraton </city> <streetAddress> 956 Omer Mountain </streetAddress> </address> <address> <country> Niue </country> <city> Port Darleneshire </city> <streetAddress> 363 Rocco Square </streetAddress> </address> <address> <country> Argentina </country> <city> Maritzamouth </city> <streetAddress> 369 Mosciski Knolls </streetAddress> </address> </addresses> </person> <person> <firstname> Louisa </firstname> <lastname> Howell </lastname> <addresses> <address> <country> Azerbaijan </country> <city> Port Alta </city> <streetAddress> 50808 Rickey Plains </streetAddress> </address> <address> <country> Congo </country> <city> North Eleonoraton </city> <streetAddress> 956 Omer Mountain </streetAddress> </address> <address> <country> Niue </country> <city> Port Darleneshire </city> <streetAddress> 363 Rocco Square </streetAddress> </address> <address> <country> Argentina </country> <city> Maritzamouth </city> <streetAddress> 369 Mosciski Knolls </streetAddress> </address> </addresses> </person> </persons>","title":"File formats"},{"location":"documentation/file-formats/#file-formats","text":"Since version 1.2.0 of Datafaker it's possible to export generated data to a file format of your choice. The currently support file formats are: CSV JSON YAML XML","title":"File formats"},{"location":"documentation/file-formats/#csv","text":"Using the CSV generation, it's possible to do the following: the number and names of columns could be specified the separator and quotes could be specified with separator() and quote() the number of lines could be specified via limit() with or without header also could be specified with header() An example can be found below: Java System . out . println ( Format . toCsv ( Csv . Column . of ( \"first_name\" , () -> faker . name (). firstName ()), Csv . Column . of ( \"last_name\" , () -> faker . name (). lastName ()), Csv . Column . of ( \"address\" , () -> faker . address (). streetAddress ())) . header ( true ) . separator ( \" ; \" ) . limit ( 5 ). build (). get ()); Executing the above will result in something similar to the below: \"first_name\" ; \"last_name\" ; \"address\" \"Jonah\" ; \"Kovacek\" ; \"009 Wilkinson Summit\" \"John\" ; \"Murphy\" ; \"379 McCullough Locks\" \"Colby\" ; \"Bins\" ; \"93534 Stevie Gardens\" \"Wade\" ; \"Herzog\" ; \"83108 Willy Road\" \"Marg\" ; \"Effertz\" ; \"415 Gene Plaza\"","title":"CSV"},{"location":"documentation/file-formats/#json","text":"It's also possible to generate JSON output: Java Faker faker = new Faker (); String json = Format . toJson ( faker . collection ( faker :: name ) . len ( 2 ) . build ()) . set ( \"firstName\" , Name :: firstName ) . set ( \"lastName\" , Name :: lastName ) . set ( \"address\" , Format . toJson ( faker . collection ( faker :: address ) . len ( 1 ) . build ()) . set ( \"country\" , Address :: country ) . set ( \"city\" , Address :: city ) . set ( \"zipcode\" , Address :: zipCode ) . set ( \"streetAddress\" , Address :: streetAddress ) . build ()) . set ( \"phones\" , name -> faker . collection (() -> faker . phoneNumber (). phoneNumber ()). maxLen ( 3 ). build (). get ()) . build () . generate (); System . out . println ( json ); This will produce something similar to the following: [{ \"firstName\" : \"Azucena\" , \"lastName\" : \"Block\" , \"address\" : [{ \"country\" : \"Micronesia\" , \"city\" : \"Ralphberg\" , \"zipcode\" : \"03792\" , \"streetAddress\" : \"522 Detra Motorway\" }], \"phones\" : [ \"885.387.7538 x3339\" , \"673-179-8684 x7840\" , \"512-510-3469 x47468\" ]}, { \"firstName\" : \"Hollis\" , \"lastName\" : \"Conroy\" , \"address\" : [{ \"country\" : \"Anguilla\" , \"city\" : \"Murrayshire\" , \"zipcode\" : \"96973\" , \"streetAddress\" : \"84545 Carolyne Hills\" }], \"phones\" : [ \"133.943.3781 x16122\" , \"797.830.4970 x310\" , \"(599) 214-5520 x920\" ]}] Another example with json payload Java Faker faker = new Faker (); String json = Format . toJson ( faker . collection ( faker :: name ). faker ( faker ) . len ( 2 ) . build ()) . set ( \"firstName\" , Name :: firstName ) . set ( \"lastName\" , Name :: lastName ) . set ( \"payload\" , payload -> Format . toJson ( faker . collection ( faker :: address ) . len ( 1 ) . build ()) . set ( \"country\" , Address :: country ) . set ( \"city\" , Address :: city ) . set ( \"zipcode\" , Address :: zipCode ) . set ( \"streetAddress\" , Address :: streetAddress ) . build (). generate ()) . set ( \"phones\" , name -> faker . collection (() -> faker . phoneNumber (). phoneNumber ()). maxLen ( 3 ). build (). get ()) . build () . generate (); System . out . println ( json ); This will produce json with escaped json payload e.g.: [{ \"firstName\" : \"Rey\" , \"lastName\" : \"Hilpert\" , \"payload\" : \"[{\\\"country\\\": \\\"Vanuatu\\\", \\\"city\\\": \\\"Douglasborough\\\", \\\"zipcode\\\": \\\"78956\\\", \\\"streetAddress\\\": \\\"15586 DuBuque Circles\\\"}]\" , \"phones\" : [ \"(739) 078-6320\" , \"(530) 089-9967 x167\" , \"422.892.6273 x46644\" ]}, { \"firstName\" : \"Timmy\" , \"lastName\" : \"Lakin\" , \"payload\" : \"[{\\\"country\\\": \\\"Chile\\\", \\\"city\\\": \\\"East Frederick\\\", \\\"zipcode\\\": \\\"07470\\\", \\\"streetAddress\\\": \\\"425 Hackett Tunnel\\\"}]\" , \"phones\" : [ \"416.215.9044\" , \"700.631.9476\" , \"1-521-484-1096\" ]}]","title":"JSON"},{"location":"documentation/file-formats/#yaml","text":"A lightweight YAML generator is now built into Datafaker. The following is an example on how to use it: Java Faker faker = new Faker (); Map < Supplier < String > , Supplier < Object >> map = new LinkedHashMap <> (); Map < Supplier < String > , Supplier < Object >> address = new LinkedHashMap <> (); Map < Supplier < String > , Supplier < Object >> phones = new LinkedHashMap <> (); phones . put (() -> \"worknumbers\" , () -> faker . < String > collection (). suppliers (() -> faker . phoneNumber (). phoneNumber ()). maxLen ( 2 ). build (). get ()); phones . put (() -> \"cellphones\" , () -> faker . < String > collection (). suppliers (() -> faker . phoneNumber (). cellPhone ()). maxLen ( 3 ). build (). get ()); address . put (() -> \"city\" , () -> faker . address (). city ()); address . put (() -> \"country\" , () -> faker . address (). country ()); address . put (() -> \"streetAddress\" , () -> faker . address (). streetAddress ()); map . put (() -> \"name\" , () -> faker . name (). firstName ()); map . put (() -> \"lastname\" , () -> faker . name (). lastName ()); map . put (() -> \"address\" , () -> address ); map . put (() -> \"phones\" , () -> phones ); Yaml yaml = new Yaml ( map ); System . out . println ( yaml . generate ());","title":"YAML"},{"location":"documentation/file-formats/#xml","text":"","title":"XML"},{"location":"documentation/file-formats/#elements-and-attributes","text":"In case you want to generate XML, Datafaker provides a facility to build XML elements and attributes using randomly generated data in the following way: Java public static void main ( String [] args ) { Faker faker = new Faker (); Collection < Xml . XmlNode > address = faker . < Xml . XmlNode > collection () . suppliers (() -> new Xml . XmlNode ( \"address\" , map ( entry ( \"country\" , faker . address (). country ()), entry ( \"city\" , faker . address (). city ()), entry ( \"streetAddress\" , faker . address (). streetAddress ())), Collections . emptyList ())) . maxLen ( 3 ). build (). get (); Collection < Xml . XmlNode > persons = faker . < Xml . XmlNode > collection () . suppliers (() -> new Xml . XmlNode ( \"person\" , map ( entry ( \"firstname\" , faker . name (). firstName ()), entry ( \"lastname\" , faker . name (). lastName ())), of ( new Xml . XmlNode ( \"addresses\" , address )))). maxLen ( 3 ). build (). get (); String str = new Xml ( new Xml . XmlNode ( \"persons\" , persons )). generate ( true ); System . out . println ( str ); } private static < T > Collection < T > of ( T ... elems ) { return Arrays . asList ( elems ); } private static Map . Entry < String , String > entry ( String key , String value ) { return new AbstractMap . SimpleEntry <> ( key , value ); } private static Map < String , String > map ( Map . Entry < String , String > ... entries ) { Map < String , String > map = new LinkedHashMap <> (); for ( Map . Entry < String , String > entry : entries ) { map . put ( entry . getKey (), entry . getValue ()); } return map ; } This will produce the following output: <persons> <person firstname= \"Chuck\" lastname= \"Rice\" > <addresses> <address country= \"Croatia\" city= \"South Stacimouth\" streetAddress= \"8958 Ervin Stravenue\" /> <address country= \"Uruguay\" city= \"South Cariefort\" streetAddress= \"59014 Howell Pike\" /> <address country= \"Bahrain\" city= \"New Ian\" streetAddress= \"446 Wuckert Brooks\" /> </addresses> </person> <person firstname= \"Brent\" lastname= \"Walter\" > <addresses> <address country= \"Croatia\" city= \"South Stacimouth\" streetAddress= \"8958 Ervin Stravenue\" /> <address country= \"Uruguay\" city= \"South Cariefort\" streetAddress= \"59014 Howell Pike\" /> <address country= \"Bahrain\" city= \"New Ian\" streetAddress= \"446 Wuckert Brooks\" /> </addresses> </person> <person firstname= \"Amy\" lastname= \"Parisian\" > <addresses> <address country= \"Croatia\" city= \"South Stacimouth\" streetAddress= \"8958 Ervin Stravenue\" /> <address country= \"Uruguay\" city= \"South Cariefort\" streetAddress= \"59014 Howell Pike\" /> <address country= \"Bahrain\" city= \"New Ian\" streetAddress= \"446 Wuckert Brooks\" /> </addresses> </person> </persons>","title":"Elements and attributes"},{"location":"documentation/file-formats/#elements-only","text":"In case you only want to generate XML elements, without any attributes, that possible too: Java Faker faker = new Faker (); Collection < Xml . XmlNode > address = faker . < Xml . XmlNode > collection () . suppliers (() -> new Xml . XmlNode ( \"address\" , of ( new Xml . XmlNode ( \"country\" , faker . address (). country ()), new Xml . XmlNode ( \"city\" , faker . address (). city ()), new Xml . XmlNode ( \"streetAddress\" , faker . address (). streetAddress ())))) . maxLen ( 4 ). build (). get (); Collection < Xml . XmlNode > persons = faker . < Xml . XmlNode > collection () . suppliers (() -> new Xml . XmlNode ( \"person\" , of ( new Xml . XmlNode ( \"firstname\" , faker . name (). firstName ()), new Xml . XmlNode ( \"lastname\" , faker . name (). lastName ()), new Xml . XmlNode ( \"addresses\" , address )))). maxLen ( 2 ). build (). get (); String str = new Xml ( new Xml . XmlNode ( \"persons\" , persons )). generate ( true ); System . out . println ( str ); Executing the above will result in: <persons> <person> <firstname> Shiloh </firstname> <lastname> Witting </lastname> <addresses> <address> <country> Azerbaijan </country> <city> Port Alta </city> <streetAddress> 50808 Rickey Plains </streetAddress> </address> <address> <country> Congo </country> <city> North Eleonoraton </city> <streetAddress> 956 Omer Mountain </streetAddress> </address> <address> <country> Niue </country> <city> Port Darleneshire </city> <streetAddress> 363 Rocco Square </streetAddress> </address> <address> <country> Argentina </country> <city> Maritzamouth </city> <streetAddress> 369 Mosciski Knolls </streetAddress> </address> </addresses> </person> <person> <firstname> Louisa </firstname> <lastname> Howell </lastname> <addresses> <address> <country> Azerbaijan </country> <city> Port Alta </city> <streetAddress> 50808 Rickey Plains </streetAddress> </address> <address> <country> Congo </country> <city> North Eleonoraton </city> <streetAddress> 956 Omer Mountain </streetAddress> </address> <address> <country> Niue </country> <city> Port Darleneshire </city> <streetAddress> 363 Rocco Square </streetAddress> </address> <address> <country> Argentina </country> <city> Maritzamouth </city> <streetAddress> 369 Mosciski Knolls </streetAddress> </address> </addresses> </person> </persons>","title":"Elements only"},{"location":"documentation/getting-started/","text":"Getting started \u00b6 Datafaker is a library for Java and Kotlin to generate fake data. This can be very helpful when generating test data to fill a database, to generate data for a stress test, or anonymize data from production services. Installation \u00b6 The latest version of Datafaker is 1.5.0 and is hosted on Maven Central. Datafaker can be included in your project using most dependency management tools: Maven Gradle (Groovy) Gradle (Kotlin) Ivy <dependency> <groupId>net.datafaker</groupId> <artifactId>datafaker</artifactId> <version>1.5.0</version> </dependency> dependencies { implementation 'net.datafaker:datafaker:1.5.0' } dependencies { implementation ( \"net.datafaker:datafaker:1.5.0\" ) } <dependency org = \"net.datafaker\" name = \"datafaker\" rev = \"1.5.0\" /> Snapshot versions \u00b6 It's also possible to use the latest snapshot version (currently 1.6.0-SNAPSHOT) by including the Sonatype snapshot repository in your configuration. A Gradle example can be found below: repositories { mavenCentral () maven ( url = \"https://s01.oss.sonatype.org/content/repositories/snapshots\" ) } dependencies { implementation ( \"net.datafaker:datafaker:1.6.0-SNAPSHOT\" ) } Usage \u00b6 To use Datafaker to generate fake data, you can use the following code as an example: Java Kotlin import net.datafaker.Faker ; Faker faker = new Faker (); String name = faker . name (). fullName (); // Miss Samanta Schmidt String firstName = faker . name (). firstName (); // Emory String lastName = faker . name (). lastName (); // Barton String streetAddress = faker . address (). streetAddress (); // 60018 Sawayn Brooks Suite 449 import net.datafaker.Faker val faker = Faker() val name = faker.name().fullName() // Miss Samanta Schmidt val firstName = faker.name().firstName() // Emory val lastName = faker.name().lastName() // Barton val streetAddress = faker.address().streetAddress() // 60018 Sawayn Brooks Suite 449 For a full list of all the fake data providers, have a look at the reference documentation.","title":"Getting started"},{"location":"documentation/getting-started/#getting-started","text":"Datafaker is a library for Java and Kotlin to generate fake data. This can be very helpful when generating test data to fill a database, to generate data for a stress test, or anonymize data from production services.","title":"Getting started"},{"location":"documentation/getting-started/#installation","text":"The latest version of Datafaker is 1.5.0 and is hosted on Maven Central. Datafaker can be included in your project using most dependency management tools: Maven Gradle (Groovy) Gradle (Kotlin) Ivy <dependency> <groupId>net.datafaker</groupId> <artifactId>datafaker</artifactId> <version>1.5.0</version> </dependency> dependencies { implementation 'net.datafaker:datafaker:1.5.0' } dependencies { implementation ( \"net.datafaker:datafaker:1.5.0\" ) } <dependency org = \"net.datafaker\" name = \"datafaker\" rev = \"1.5.0\" />","title":"Installation"},{"location":"documentation/getting-started/#snapshot-versions","text":"It's also possible to use the latest snapshot version (currently 1.6.0-SNAPSHOT) by including the Sonatype snapshot repository in your configuration. A Gradle example can be found below: repositories { mavenCentral () maven ( url = \"https://s01.oss.sonatype.org/content/repositories/snapshots\" ) } dependencies { implementation ( \"net.datafaker:datafaker:1.6.0-SNAPSHOT\" ) }","title":"Snapshot versions"},{"location":"documentation/getting-started/#usage","text":"To use Datafaker to generate fake data, you can use the following code as an example: Java Kotlin import net.datafaker.Faker ; Faker faker = new Faker (); String name = faker . name (). fullName (); // Miss Samanta Schmidt String firstName = faker . name (). firstName (); // Emory String lastName = faker . name (). lastName (); // Barton String streetAddress = faker . address (). streetAddress (); // 60018 Sawayn Brooks Suite 449 import net.datafaker.Faker val faker = Faker() val name = faker.name().fullName() // Miss Samanta Schmidt val firstName = faker.name().firstName() // Emory val lastName = faker.name().lastName() // Barton val streetAddress = faker.address().streetAddress() // 60018 Sawayn Brooks Suite 449 For a full list of all the fake data providers, have a look at the reference documentation.","title":"Usage"},{"location":"documentation/license/","text":"License \u00b6 Datafaker is licensed under the Apache License 2.0 Copyright 2014 DataFaker.net Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"documentation/license/#license","text":"Datafaker is licensed under the Apache License 2.0 Copyright 2014 DataFaker.net Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"documentation/performance/","text":"Performance benchmarks \u00b6 This page is trying to go through some performance metrics and see how better/worse Data Faker is in compare with Java Faker and other similar projects. Hardware & Software \u00b6 All the tests are done with help of JMH at Fedora 36 for different JDKs (mentioned in tables below). The laptop has 32Gb of RAM, AMD Ryzen 7 PRO 5850U with Radeon Graphics. Data Faker (1.4.0) vs Java Faker (1.0.2) vs Kotlin-faker (1.11.0) vs JFairy (0.6.5) \u00b6 Originally Data Faker has been started as a fork of java-faker. In internet there are complaints about java-faker poor performance. Now there has been already 1.4.0 version released. Let's see what we can say about performance improvements. For that we are going to use JMH benchmarks. All the code is available as a separate project because of license reasons. Since it's hardly possible and reasonable to compare each method's performance let's see what exactly we are going to compare within this article. As it could be seen below Data Faker is about 10x-100x times faster for some cases. Also, there is an interesting fact: in case of Data Faker moving from jdk8 to jdk18 performance is improving up to 25%, while for Java Faker it is not happening. It seems in Java Faker there are some time-consuming operations blocking such improvements from updating java version which partially were fixed in Data Faker There is also Kotlin-faker . And it has a performance comparison table in README page. Unfortunately there is not so much information what kind of benchmarks have been executed. After some search across the project I was able to find only this page So, it looks like the only test which were done is checking Faker.name().name() performance. Ok, let's start with the similar test here. Similar, because we are going to use JMH which was not used in their test. If applicable we try to execute same tests we did for previous section. So let's start with the original test from Kotlin Faker Original Kotlin Faker Test \u00b6 (for different libs there should be different classes, for more details look in the code): net.datafaker.benchmark.kotlinfakerbenchmark Project Java Version Mode Cnt Score Units Data Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 avgt 10 2352.789 \u00b1 61.214 ms/op Data Faker openjdk-11.0.15.0.10-1.fc36.x86_64 avgt 10 2428.885 \u00b1 19.153 ms/op Data Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 avgt 10 1985.712 \u00b1 27.692 ms/op Java Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 avgt 10 12026.367 \u00b1 103.005 ms/op Java Faker openjdk-11.0.15.0.10-1.fc36.x86_64 avgt 10 11985.717 \u00b1 202.768 ms/op Java Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 avgt 10 9910.120 \u00b1 334.016 ms/op JFairy openjdk-1.8.0.332.b09-1.fc36.x86_64 avgt 10 10429.579 \u00b1 79.899 ms/op JFairy openjdk-11.0.15.0.10-1.fc36.x86_64 avgt 10 8921.440 \u00b1 88.582 ms/op JFairy openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 avgt 10 8371.050 \u00b1 47.380 ms/op Kotlin Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 avgt 10 2530.238 \u00b1 86.146 ms/op Kotlin Faker openjdk-11.0.15.0.10-1.fc36.x86_64 avgt 10 2522.862 \u00b1 19.028 ms/op Kotlin Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 avgt 10 2376.537 \u00b1 28.235 ms/op ATTENTION! In this test we measure not throughput but the average time of one operation => lower is better. In general, we could say that for jdk8 and jdk11 timings for Data Faker and Kotlin Faker are more or less similar and for jdk18 Data Faker is about 20% faster. JFairy and Java Faker are far behind. Initialization \u00b6 It's worse to measure since initially during initialization of Faker object it requires to initialise all the providers objects and read all the yaml files for providers. Tests for initialization could be found at net.datafaker.benchmark.initialization Initialization: Project Java Version Mode Cnt Score Units Data Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 2446.670 \u00b1 15.040 ops/ms Data Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 2633.235 \u00b1 143.345 ops/ms Data Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 3840.849 \u00b1 143.408 ops/ms Java Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 23.834 \u00b1 0.217 ops/ms Java Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 23.316 \u00b1 0.417 ops/ms Java Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 27.717 \u00b1 0.575 ops/ms JFairy openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 0.266 \u00b1 0.008 ops/ms JFairy openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 0.253 \u00b1 0.015 ops/ms JFairy openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 0.276 \u00b1 0.006 ops/ms Kotlin Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 0.017 \u00b1 0.001 ops/ms Kotlin Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 0.017 \u00b1 0.001 ops/ms Kotlin Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 0.018 \u00b1 0.001 ops/ms Simple methods fullname , firstname , address \u00b6 Performance of simple method calls like fullname , firstname , address Tests could be found at net.datafaker.benchmark.simplemethods Firstname: \u00b6 Project Java Version Mode Cnt Score Units Data Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 1381.132 \u00b1 9.388 ops/ms Data Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 1523.378 \u00b1 10.667 ops/ms Data Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 1640.834 \u00b1 59.306 ops/ms Java Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 232.055 \u00b1 2.842 ops/ms Java Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 257.667 \u00b1 1.610 ops/ms Java Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 301.318 \u00b1 2.774 ops/ms JFairy openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 114.971 \u00b1 0.881 ops/ms JFairy openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 137.098 \u00b1 2.846 ops/ms JFairy openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 148.091 \u00b1 2.048 ops/ms Kotlin Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 904.868 \u00b1 6.883 ops/ms Kotlin Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 965.916 \u00b1 27.270 ops/ms Kotlin Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 1074.216 \u00b1 98.063 ops/ms Fullname: \u00b6 Project Java Version Mode Cnt Score Units Data Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 433.824 \u00b1 21.696 ops/ms Data Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 517.713 \u00b1 24.944 ops/ms Data Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 535.289 \u00b1 5.651 ops/ms Java Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 81.282 \u00b1 1.199 ops/ms Java Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 85.278 \u00b1 2.770 ops/ms Java Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 106.813 \u00b1 1.710 ops/ms JFairy openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 114.874 \u00b1 0.564 ops/ms JFairy openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 136.762 \u00b1 1.933 ops/ms JFairy openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 143.378 \u00b1 1.582 ops/ms Kotlin Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 407.972 \u00b1 6.095 ops/ms Kotlin Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 447.162 \u00b1 5.546 ops/ms Kotlin Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 448.645 \u00b1 28.789 ops/ms StreetAddress: \u00b6 Project Java Version Mode Cnt Score Units Data Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 291.779 \u00b1 3.699 ops/ms Data Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 319.959 \u00b1 7.984 ops/ms Data Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 339.846 \u00b1 9.068 ops/ms Java Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 42.421 \u00b1 0.497 ops/ms Java Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 43.939 \u00b1 0.571 ops/ms Java Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 66.658 \u00b1 0.811 ops/ms JFairy openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 113.572 \u00b1 1.644 ops/ms JFairy openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 136.216 \u00b1 0.465 ops/ms JFairy openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 145.778 \u00b1 2.186 ops/ms Kotlin Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 76.850 \u00b1 6.447 ops/ms Kotlin Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 100.451 \u00b1 0.480 ops/ms Kotlin Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 99.861 \u00b1 1.799 ops/ms String template operations \u00b6 From one side Kotlin Faker and JFairy do not support expressions, from the other side Kotlin Faker supports numerify/bothify/letterify and regexify operations. So, the tests are done based on Kotlin Faker's doc page Numerify: \u00b6 Project Java Version Mode Cnt Score Units Data Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 46027.055 \u00b1 4323.326 ops/ms Data Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 45048.868 \u00b1 1976.526 ops/ms Data Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 47427.468 \u00b1 423.228 ops/ms Java Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 27089.972 \u00b1 1244.279 ops/ms Java Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 23325.344 \u00b1 265.684 ops/ms Java Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 30599.747 \u00b1 548.377 ops/ms Kotlin Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 4503.070 \u00b1 60.716 ops/ms Kotlin Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 4886.276 \u00b1 51.213 ops/ms Kotlin Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 5504.774 \u00b1 57.402 ops/ms #### Letterify: Subject Java Version Mode Cnt Score Units Data Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 41273.044 \u00b1 1247.091 ops/ms Data Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 47005.203 \u00b1 2799.484 ops/ms Data Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 48441.249 \u00b1 1040.172 ops/ms Java Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 30510.549 \u00b1 589.002 ops/ms Java Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 30869.658 \u00b1 2137.318 ops/ms Java Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 21462.296 \u00b1 530.481 ops/ms Kotlin Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 4861.635 \u00b1 69.498 ops/ms Kotlin Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 4746.286 \u00b1 71.018 ops/ms Kotlin Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 5223.486 \u00b1 46.612 ops/ms #### Bothify: Subject Java Version Mode Cnt Score Units Data Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 21785.504 \u00b1 596.322 ops/ms Data Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 22618.331 \u00b1 825.949 ops/ms Data Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 23757.533 \u00b1 172.493 ops/ms Java Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 11096.829 \u00b1 574.783 ops/ms Java Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 9118.489 \u00b1 336.647 ops/ms Java Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 8296.013 \u00b1 76.493 ops/ms Kotlin Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 1693.124 \u00b1 62.691 ops/ms Kotlin Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 1762.054 \u00b1 78.296 ops/ms Kotlin Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 1908.346 \u00b1 41.831 ops/ms Regexify: \u00b6 Subject Java Version Mode Cnt Score Units Data Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 2206.095 \u00b1 33.280 ops/ms Data Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 2616.809 \u00b1 34.568 ops/ms Data Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 3454.312 \u00b1 11.464 ops/ms Java Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 267.981 \u00b1 3.333 ops/ms Java Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 261.420 \u00b1 0.822 ops/ms Java Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 325.523 \u00b1 2.777 ops/ms Kotlin Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 366.627 \u00b1 23.346 ops/ms Kotlin Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 347.008 \u00b1 3.380 ops/ms Kotlin Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 434.123 \u00b1 1.089 ops/ms Expressions \u00b6 Since both Java Faker and Dara Faker provide expression functionality like letterify, bothify, regexify, it would make sense to see the difference. Here, it is also worth mentioning that for different patterns score could be different, however it is impossible to check all. net.datafaker.benchmark.templatestrings.DatafakerTemplateStrings Bothify expression: \u00b6 Project Java Version Mode Cnt Score Units Data Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 1918.381 \u00b1 91.410 ops/ms Data Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 1868.298 \u00b1 27.953 ops/ms Data Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 2169.941 \u00b1 45.504 ops/ms Java Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 207.428 \u00b1 2.923 ops/ms Java Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 208.868 \u00b1 2.023 ops/ms Java Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 298.704 \u00b1 4.315 ops/ms Letterify expression: \u00b6 Project Java Version Mode Cnt Score Units Data Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 1821.056 \u00b1 70.109 ops/ms Data Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 1922.130 \u00b1 16.922 ops/ms Data Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 2104.585 \u00b1 81.704 ops/ms Java Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 205.280 \u00b1 3.724 ops/ms Java Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 208.239 \u00b1 1.535 ops/ms Java Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 316.426 \u00b1 5.495 ops/ms Regexify expression: \u00b6 Project Java Version Mode Cnt Score Units Data Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 1273.177 \u00b1 8.818 ops/ms Data Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 1235.418 \u00b1 11.646 ops/ms Data Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 1607.923 \u00b1 34.328 ops/ms Java Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 120.409 \u00b1 0.993 ops/ms Java Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 121.226 \u00b1 0.670 ops/ms Java Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 158.919 \u00b1 1.609 ops/ms Method invocations \u00b6 Also, both Java Faker and Data Faker allow invocation of methods from expression. Let's consider an example where in expression it is required to parse and process only one method. Here there was added cache for parsing of methods. Since only Data Faker and Java Faker support it there are only these 2 projects Project Java Version Mode Cnt Score Units Data Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 1020.388 \u00b1 12.270 ops/ms Data Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 1057.132 \u00b1 27.611 ops/ms Data Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 1113.307 \u00b1 21.496 ops/ms Java Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 145.144 \u00b1 2.523 ops/ms Java Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 147.812 \u00b1 2.206 ops/ms Java Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 207.275 \u00b1 3.522 ops/ms Similar example as previous, however there are 3 methods. Besides, cache of parsed methods there was also added cache for parsed args. Project Java Version Mode Cnt Score Units Data Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 276.175 \u00b1 6.503 ops/ms Data Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 321.559 \u00b1 12.098 ops/ms Data Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 334.248 \u00b1 12.733 ops/ms Java Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 33.567 \u00b1 0.515 ops/ms Java Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 36.055 \u00b1 0.460 ops/ms Java Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 49.014 \u00b1 1.994 ops/ms It makes sense to keep in mind that these tests do not cover all possible use cases and could be considered only as a starting point for analysis. More Fun \u00b6 There is an issue in Java Faker about generation of 100M of objects. Of course, the task could be solved with concurrent generation in multiple threads. However, here it is interesting how much can 1 thread application within 1 hour. The code below for Data Faker generates a bit more than 170M objects for 1 hour. Same code for Java Faker generates about 38M for 1 hour. Kotlin Faker does not support setting of birthday and blood. Without these 2 params it generates about 90M for 1 hour. net.datafaker.benchmark.generate_one_hour","title":"Performance"},{"location":"documentation/performance/#performance-benchmarks","text":"This page is trying to go through some performance metrics and see how better/worse Data Faker is in compare with Java Faker and other similar projects.","title":"Performance benchmarks"},{"location":"documentation/performance/#hardware-software","text":"All the tests are done with help of JMH at Fedora 36 for different JDKs (mentioned in tables below). The laptop has 32Gb of RAM, AMD Ryzen 7 PRO 5850U with Radeon Graphics.","title":"Hardware &amp; Software"},{"location":"documentation/performance/#data-faker-140-vs-java-faker-102-vs-kotlin-faker-1110-vs-jfairy-065","text":"Originally Data Faker has been started as a fork of java-faker. In internet there are complaints about java-faker poor performance. Now there has been already 1.4.0 version released. Let's see what we can say about performance improvements. For that we are going to use JMH benchmarks. All the code is available as a separate project because of license reasons. Since it's hardly possible and reasonable to compare each method's performance let's see what exactly we are going to compare within this article. As it could be seen below Data Faker is about 10x-100x times faster for some cases. Also, there is an interesting fact: in case of Data Faker moving from jdk8 to jdk18 performance is improving up to 25%, while for Java Faker it is not happening. It seems in Java Faker there are some time-consuming operations blocking such improvements from updating java version which partially were fixed in Data Faker There is also Kotlin-faker . And it has a performance comparison table in README page. Unfortunately there is not so much information what kind of benchmarks have been executed. After some search across the project I was able to find only this page So, it looks like the only test which were done is checking Faker.name().name() performance. Ok, let's start with the similar test here. Similar, because we are going to use JMH which was not used in their test. If applicable we try to execute same tests we did for previous section. So let's start with the original test from Kotlin Faker","title":"Data Faker (1.4.0) vs Java Faker (1.0.2) vs Kotlin-faker (1.11.0) vs JFairy (0.6.5)"},{"location":"documentation/performance/#original-kotlin-faker-test","text":"(for different libs there should be different classes, for more details look in the code): net.datafaker.benchmark.kotlinfakerbenchmark Project Java Version Mode Cnt Score Units Data Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 avgt 10 2352.789 \u00b1 61.214 ms/op Data Faker openjdk-11.0.15.0.10-1.fc36.x86_64 avgt 10 2428.885 \u00b1 19.153 ms/op Data Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 avgt 10 1985.712 \u00b1 27.692 ms/op Java Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 avgt 10 12026.367 \u00b1 103.005 ms/op Java Faker openjdk-11.0.15.0.10-1.fc36.x86_64 avgt 10 11985.717 \u00b1 202.768 ms/op Java Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 avgt 10 9910.120 \u00b1 334.016 ms/op JFairy openjdk-1.8.0.332.b09-1.fc36.x86_64 avgt 10 10429.579 \u00b1 79.899 ms/op JFairy openjdk-11.0.15.0.10-1.fc36.x86_64 avgt 10 8921.440 \u00b1 88.582 ms/op JFairy openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 avgt 10 8371.050 \u00b1 47.380 ms/op Kotlin Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 avgt 10 2530.238 \u00b1 86.146 ms/op Kotlin Faker openjdk-11.0.15.0.10-1.fc36.x86_64 avgt 10 2522.862 \u00b1 19.028 ms/op Kotlin Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 avgt 10 2376.537 \u00b1 28.235 ms/op ATTENTION! In this test we measure not throughput but the average time of one operation => lower is better. In general, we could say that for jdk8 and jdk11 timings for Data Faker and Kotlin Faker are more or less similar and for jdk18 Data Faker is about 20% faster. JFairy and Java Faker are far behind.","title":"Original Kotlin Faker Test"},{"location":"documentation/performance/#initialization","text":"It's worse to measure since initially during initialization of Faker object it requires to initialise all the providers objects and read all the yaml files for providers. Tests for initialization could be found at net.datafaker.benchmark.initialization Initialization: Project Java Version Mode Cnt Score Units Data Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 2446.670 \u00b1 15.040 ops/ms Data Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 2633.235 \u00b1 143.345 ops/ms Data Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 3840.849 \u00b1 143.408 ops/ms Java Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 23.834 \u00b1 0.217 ops/ms Java Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 23.316 \u00b1 0.417 ops/ms Java Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 27.717 \u00b1 0.575 ops/ms JFairy openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 0.266 \u00b1 0.008 ops/ms JFairy openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 0.253 \u00b1 0.015 ops/ms JFairy openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 0.276 \u00b1 0.006 ops/ms Kotlin Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 0.017 \u00b1 0.001 ops/ms Kotlin Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 0.017 \u00b1 0.001 ops/ms Kotlin Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 0.018 \u00b1 0.001 ops/ms","title":"Initialization"},{"location":"documentation/performance/#simple-methods-fullname-firstname-address","text":"Performance of simple method calls like fullname , firstname , address Tests could be found at net.datafaker.benchmark.simplemethods","title":"Simple methods fullname, firstname, address"},{"location":"documentation/performance/#firstname","text":"Project Java Version Mode Cnt Score Units Data Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 1381.132 \u00b1 9.388 ops/ms Data Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 1523.378 \u00b1 10.667 ops/ms Data Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 1640.834 \u00b1 59.306 ops/ms Java Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 232.055 \u00b1 2.842 ops/ms Java Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 257.667 \u00b1 1.610 ops/ms Java Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 301.318 \u00b1 2.774 ops/ms JFairy openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 114.971 \u00b1 0.881 ops/ms JFairy openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 137.098 \u00b1 2.846 ops/ms JFairy openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 148.091 \u00b1 2.048 ops/ms Kotlin Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 904.868 \u00b1 6.883 ops/ms Kotlin Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 965.916 \u00b1 27.270 ops/ms Kotlin Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 1074.216 \u00b1 98.063 ops/ms","title":"Firstname:"},{"location":"documentation/performance/#fullname","text":"Project Java Version Mode Cnt Score Units Data Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 433.824 \u00b1 21.696 ops/ms Data Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 517.713 \u00b1 24.944 ops/ms Data Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 535.289 \u00b1 5.651 ops/ms Java Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 81.282 \u00b1 1.199 ops/ms Java Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 85.278 \u00b1 2.770 ops/ms Java Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 106.813 \u00b1 1.710 ops/ms JFairy openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 114.874 \u00b1 0.564 ops/ms JFairy openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 136.762 \u00b1 1.933 ops/ms JFairy openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 143.378 \u00b1 1.582 ops/ms Kotlin Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 407.972 \u00b1 6.095 ops/ms Kotlin Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 447.162 \u00b1 5.546 ops/ms Kotlin Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 448.645 \u00b1 28.789 ops/ms","title":"Fullname:"},{"location":"documentation/performance/#streetaddress","text":"Project Java Version Mode Cnt Score Units Data Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 291.779 \u00b1 3.699 ops/ms Data Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 319.959 \u00b1 7.984 ops/ms Data Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 339.846 \u00b1 9.068 ops/ms Java Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 42.421 \u00b1 0.497 ops/ms Java Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 43.939 \u00b1 0.571 ops/ms Java Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 66.658 \u00b1 0.811 ops/ms JFairy openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 113.572 \u00b1 1.644 ops/ms JFairy openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 136.216 \u00b1 0.465 ops/ms JFairy openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 145.778 \u00b1 2.186 ops/ms Kotlin Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 76.850 \u00b1 6.447 ops/ms Kotlin Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 100.451 \u00b1 0.480 ops/ms Kotlin Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 99.861 \u00b1 1.799 ops/ms","title":"StreetAddress:"},{"location":"documentation/performance/#string-template-operations","text":"From one side Kotlin Faker and JFairy do not support expressions, from the other side Kotlin Faker supports numerify/bothify/letterify and regexify operations. So, the tests are done based on Kotlin Faker's doc page","title":"String template operations"},{"location":"documentation/performance/#numerify","text":"Project Java Version Mode Cnt Score Units Data Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 46027.055 \u00b1 4323.326 ops/ms Data Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 45048.868 \u00b1 1976.526 ops/ms Data Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 47427.468 \u00b1 423.228 ops/ms Java Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 27089.972 \u00b1 1244.279 ops/ms Java Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 23325.344 \u00b1 265.684 ops/ms Java Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 30599.747 \u00b1 548.377 ops/ms Kotlin Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 4503.070 \u00b1 60.716 ops/ms Kotlin Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 4886.276 \u00b1 51.213 ops/ms Kotlin Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 5504.774 \u00b1 57.402 ops/ms #### Letterify: Subject Java Version Mode Cnt Score Units Data Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 41273.044 \u00b1 1247.091 ops/ms Data Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 47005.203 \u00b1 2799.484 ops/ms Data Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 48441.249 \u00b1 1040.172 ops/ms Java Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 30510.549 \u00b1 589.002 ops/ms Java Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 30869.658 \u00b1 2137.318 ops/ms Java Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 21462.296 \u00b1 530.481 ops/ms Kotlin Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 4861.635 \u00b1 69.498 ops/ms Kotlin Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 4746.286 \u00b1 71.018 ops/ms Kotlin Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 5223.486 \u00b1 46.612 ops/ms #### Bothify: Subject Java Version Mode Cnt Score Units Data Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 21785.504 \u00b1 596.322 ops/ms Data Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 22618.331 \u00b1 825.949 ops/ms Data Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 23757.533 \u00b1 172.493 ops/ms Java Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 11096.829 \u00b1 574.783 ops/ms Java Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 9118.489 \u00b1 336.647 ops/ms Java Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 8296.013 \u00b1 76.493 ops/ms Kotlin Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 1693.124 \u00b1 62.691 ops/ms Kotlin Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 1762.054 \u00b1 78.296 ops/ms Kotlin Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 1908.346 \u00b1 41.831 ops/ms","title":"Numerify:"},{"location":"documentation/performance/#regexify","text":"Subject Java Version Mode Cnt Score Units Data Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 2206.095 \u00b1 33.280 ops/ms Data Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 2616.809 \u00b1 34.568 ops/ms Data Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 3454.312 \u00b1 11.464 ops/ms Java Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 267.981 \u00b1 3.333 ops/ms Java Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 261.420 \u00b1 0.822 ops/ms Java Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 325.523 \u00b1 2.777 ops/ms Kotlin Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 366.627 \u00b1 23.346 ops/ms Kotlin Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 347.008 \u00b1 3.380 ops/ms Kotlin Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 434.123 \u00b1 1.089 ops/ms","title":"Regexify:"},{"location":"documentation/performance/#expressions","text":"Since both Java Faker and Dara Faker provide expression functionality like letterify, bothify, regexify, it would make sense to see the difference. Here, it is also worth mentioning that for different patterns score could be different, however it is impossible to check all. net.datafaker.benchmark.templatestrings.DatafakerTemplateStrings","title":"Expressions"},{"location":"documentation/performance/#bothify-expression","text":"Project Java Version Mode Cnt Score Units Data Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 1918.381 \u00b1 91.410 ops/ms Data Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 1868.298 \u00b1 27.953 ops/ms Data Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 2169.941 \u00b1 45.504 ops/ms Java Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 207.428 \u00b1 2.923 ops/ms Java Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 208.868 \u00b1 2.023 ops/ms Java Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 298.704 \u00b1 4.315 ops/ms","title":"Bothify expression:"},{"location":"documentation/performance/#letterify-expression","text":"Project Java Version Mode Cnt Score Units Data Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 1821.056 \u00b1 70.109 ops/ms Data Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 1922.130 \u00b1 16.922 ops/ms Data Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 2104.585 \u00b1 81.704 ops/ms Java Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 205.280 \u00b1 3.724 ops/ms Java Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 208.239 \u00b1 1.535 ops/ms Java Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 316.426 \u00b1 5.495 ops/ms","title":"Letterify expression:"},{"location":"documentation/performance/#regexify-expression","text":"Project Java Version Mode Cnt Score Units Data Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 1273.177 \u00b1 8.818 ops/ms Data Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 1235.418 \u00b1 11.646 ops/ms Data Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 1607.923 \u00b1 34.328 ops/ms Java Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 120.409 \u00b1 0.993 ops/ms Java Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 121.226 \u00b1 0.670 ops/ms Java Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 158.919 \u00b1 1.609 ops/ms","title":"Regexify expression:"},{"location":"documentation/performance/#method-invocations","text":"Also, both Java Faker and Data Faker allow invocation of methods from expression. Let's consider an example where in expression it is required to parse and process only one method. Here there was added cache for parsing of methods. Since only Data Faker and Java Faker support it there are only these 2 projects Project Java Version Mode Cnt Score Units Data Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 1020.388 \u00b1 12.270 ops/ms Data Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 1057.132 \u00b1 27.611 ops/ms Data Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 1113.307 \u00b1 21.496 ops/ms Java Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 145.144 \u00b1 2.523 ops/ms Java Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 147.812 \u00b1 2.206 ops/ms Java Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 207.275 \u00b1 3.522 ops/ms Similar example as previous, however there are 3 methods. Besides, cache of parsed methods there was also added cache for parsed args. Project Java Version Mode Cnt Score Units Data Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 276.175 \u00b1 6.503 ops/ms Data Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 321.559 \u00b1 12.098 ops/ms Data Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 334.248 \u00b1 12.733 ops/ms Java Faker openjdk-1.8.0.332.b09-1.fc36.x86_64 thrpt 10 33.567 \u00b1 0.515 ops/ms Java Faker openjdk-11.0.15.0.10-1.fc36.x86_64 thrpt 10 36.055 \u00b1 0.460 ops/ms Java Faker openjdk-18.0.1.0.10-1.rolling.fc36.x86_64 thrpt 10 49.014 \u00b1 1.994 ops/ms It makes sense to keep in mind that these tests do not cover all possible use cases and could be considered only as a starting point for analysis.","title":"Method invocations"},{"location":"documentation/performance/#more-fun","text":"There is an issue in Java Faker about generation of 100M of objects. Of course, the task could be solved with concurrent generation in multiple threads. However, here it is interesting how much can 1 thread application within 1 hour. The code below for Data Faker generates a bit more than 170M objects for 1 hour. Same code for Java Faker generates about 38M for 1 hour. Kotlin Faker does not support setting of birthday and blood. Without these 2 params it generates about 90M for 1 hour. net.datafaker.benchmark.generate_one_hour","title":"More Fun"},{"location":"documentation/providers/","text":"Fake Data Providers \u00b6 Datafaker comes with the following list of data providers: Name Description Since Address 0.8.0 Ancient 0.8.0 Animal 0.8.0 App 0.8.0 Appliance 1.0.0 Aqua Teen Hunger Force 0.8.0 Artist 0.8.0 Avatar 0.8.0 Aviation 0.8.0 AWS 1.3.0 Babylon 5 0.9.0 Back To The Future 0.8.0 Barcode 0.9.0 Basketball 0.8.0 Battlefield 1 1.4.0 Beer 0.8.0 Blood Type 1.4.0 Bojack Horseman 0.8.0 Book 0.8.0 Bool 0.8.0 Bossa Nova 1.0.0 BreakingBad 1.0.0 Brooklyn Nine Nine 1.3.0 Business 0.8.0 CNPJ Cadastro Nacional da Pessoa Jur\u00eddica in Portuguese, or 'National Registry of Legal Entities' 1.1.0 CPF Brazilian individual taxpayer registry identification 0.8.0 Camera 1.4.0 Cat 0.8.0 Chuck Norris 0.8.0 Code 0.8.0 Coin 0.8.0 Color 0.8.0 Commerce 0.8.0 Company 0.8.0 Crypto Coin 1.3.0 Date And Time 0.8.0 Demographic 0.8.0 Dessert 0.9.0 Device 1.4.0 Disease 0.8.0 Dog 0.8.0 Domain 0.9.0 Dragon Ball 0.8.0 Dune 0.8.0 Durations 0.9.0 Educator 0.8.0 Elden Ring 1.4.0 Electrical Components 1.4.0 England FootBall 0.9.0 Esports 0.8.0 File 0.8.0 Finance 0.8.0 Food 0.8.0 Friends 0.8.0 Funny Name 0.8.0 Game Of Thrones 0.8.0 Gender 0.8.0 Grateful Dead 1.4.0 Hacker 0.8.0 Harry Potter 0.8.0 Hashing 0.8.0 Heartstone 0.9.0 Hey Arnold 1.4.0 Hipster 0.8.0 Hitchhikers Guide To The Galaxy 0.8.0 Hobbit 0.8.0 Hobby 1.3.0 Horse 1.3.0 How I Met Your Mother 0.8.0 IdNumber 0.8.0 Internet 0.8.0 Job 0.8.0 Kaamelott 0.8.0 K Pop 1.3.0 League Of Legends 0.8.0 Lebowski 0.8.0 Lord Of The Rings 0.8.0 Lorem 0.8.0 Matz 0.8.0 Marketing 1.2.0 Medical 0.8.0 Military 1.2.0 Minecraft 0.9.0 Mood 0.9.0 Mountaineering 1.4.0 Mountains Support for mountains and mountain ranges 1.1.0 Music 0.8.0 Name 0.8.0 Nation 0.8.0 Nato Phonetic Alphabet 1.2.0 Number 0.8.0 Oscar Movie 1.4.0 Options 0.8.0 Overwatch 0.8.0 Passport 0.9.0 Phone Number 0.8.0 Photography 0.8.0 Pokemon 0.8.0 Princess Bride 0.8.0 Relationship Terms 0.8.0 Resident Evil 0.9.0 Restaurant 1.2.0 Rick And Morty 0.8.0 Robin 0.8.0 RockBand 0.8.0 RuPaul's Drag Race 1.0.0 Seinfeld 1.4.0 Shakespeare 0.8.0 Sip 0.8.0 Slack Emoji 0.8.0 Soul Knight 1.4.0 Space 0.8.0 StarCraft 0.8.0 Star Trek 0.8.0 Stock 0.8.0 Superhero 0.8.0 Subscription 1.3.0 Super Mario 1.3.0 Tea 1.4.0 Team 0.8.0 The IT Crowd 1.2.0 Time 1.4.0 Touhou 0.9.0 Tron 1.4.0 Twin Peaks 0.8.0 Twitter 0.9.0 University 0.8.0 Vehicle 0.9.0 Volleyball 1.3.0 Weather 0.8.0 Witcher 0.8.0 Yoda 0.8.0 Zelda 0.8.0","title":"Data providers"},{"location":"documentation/providers/#fake-data-providers","text":"Datafaker comes with the following list of data providers: Name Description Since Address 0.8.0 Ancient 0.8.0 Animal 0.8.0 App 0.8.0 Appliance 1.0.0 Aqua Teen Hunger Force 0.8.0 Artist 0.8.0 Avatar 0.8.0 Aviation 0.8.0 AWS 1.3.0 Babylon 5 0.9.0 Back To The Future 0.8.0 Barcode 0.9.0 Basketball 0.8.0 Battlefield 1 1.4.0 Beer 0.8.0 Blood Type 1.4.0 Bojack Horseman 0.8.0 Book 0.8.0 Bool 0.8.0 Bossa Nova 1.0.0 BreakingBad 1.0.0 Brooklyn Nine Nine 1.3.0 Business 0.8.0 CNPJ Cadastro Nacional da Pessoa Jur\u00eddica in Portuguese, or 'National Registry of Legal Entities' 1.1.0 CPF Brazilian individual taxpayer registry identification 0.8.0 Camera 1.4.0 Cat 0.8.0 Chuck Norris 0.8.0 Code 0.8.0 Coin 0.8.0 Color 0.8.0 Commerce 0.8.0 Company 0.8.0 Crypto Coin 1.3.0 Date And Time 0.8.0 Demographic 0.8.0 Dessert 0.9.0 Device 1.4.0 Disease 0.8.0 Dog 0.8.0 Domain 0.9.0 Dragon Ball 0.8.0 Dune 0.8.0 Durations 0.9.0 Educator 0.8.0 Elden Ring 1.4.0 Electrical Components 1.4.0 England FootBall 0.9.0 Esports 0.8.0 File 0.8.0 Finance 0.8.0 Food 0.8.0 Friends 0.8.0 Funny Name 0.8.0 Game Of Thrones 0.8.0 Gender 0.8.0 Grateful Dead 1.4.0 Hacker 0.8.0 Harry Potter 0.8.0 Hashing 0.8.0 Heartstone 0.9.0 Hey Arnold 1.4.0 Hipster 0.8.0 Hitchhikers Guide To The Galaxy 0.8.0 Hobbit 0.8.0 Hobby 1.3.0 Horse 1.3.0 How I Met Your Mother 0.8.0 IdNumber 0.8.0 Internet 0.8.0 Job 0.8.0 Kaamelott 0.8.0 K Pop 1.3.0 League Of Legends 0.8.0 Lebowski 0.8.0 Lord Of The Rings 0.8.0 Lorem 0.8.0 Matz 0.8.0 Marketing 1.2.0 Medical 0.8.0 Military 1.2.0 Minecraft 0.9.0 Mood 0.9.0 Mountaineering 1.4.0 Mountains Support for mountains and mountain ranges 1.1.0 Music 0.8.0 Name 0.8.0 Nation 0.8.0 Nato Phonetic Alphabet 1.2.0 Number 0.8.0 Oscar Movie 1.4.0 Options 0.8.0 Overwatch 0.8.0 Passport 0.9.0 Phone Number 0.8.0 Photography 0.8.0 Pokemon 0.8.0 Princess Bride 0.8.0 Relationship Terms 0.8.0 Resident Evil 0.9.0 Restaurant 1.2.0 Rick And Morty 0.8.0 Robin 0.8.0 RockBand 0.8.0 RuPaul's Drag Race 1.0.0 Seinfeld 1.4.0 Shakespeare 0.8.0 Sip 0.8.0 Slack Emoji 0.8.0 Soul Knight 1.4.0 Space 0.8.0 StarCraft 0.8.0 Star Trek 0.8.0 Stock 0.8.0 Superhero 0.8.0 Subscription 1.3.0 Super Mario 1.3.0 Tea 1.4.0 Team 0.8.0 The IT Crowd 1.2.0 Time 1.4.0 Touhou 0.9.0 Tron 1.4.0 Twin Peaks 0.8.0 Twitter 0.9.0 University 0.8.0 Vehicle 0.9.0 Volleyball 1.3.0 Weather 0.8.0 Witcher 0.8.0 Yoda 0.8.0 Zelda 0.8.0","title":"Fake Data Providers"},{"location":"documentation/usage/","text":"Usage \u00b6 The simplest way to use Datafaker to generate fake data is by instantiating the Faker using the default constructor. Default usage \u00b6 Java Kotlin import net.datafaker.Faker ; Faker faker = new Faker (); String name = faker . name (). fullName (); // Miss Samanta Schmidt import net.datafaker.Faker val faker = Faker() val name = faker.name().fullName() // Miss Samanta Schmidt This will instantiate a Faker using the English locale. Different locale \u00b6 To use Datafaker with a different locale, you can supply on in the constructor as such: Java Kotlin Faker faker = new Faker ( new Locale ( \"nl\" )); String name = faker . name (). fullName (); // Chelan Klijnsma val faker = Faker ( Locale ( \"nl\" )) val name = faker . name (). fullName () // Chelan Klijnsma Multiple locales \u00b6 In case you want to mix locales, the easiest way to do so is to create a Faker per locale, and mix between those fakers. For an example, see below, which produce something like the following: 8708 \u0634\u0627\u0631\u0639 \u0642\u0637\u0631, \u0645\u062f\u064a\u0646\u0629 \u062e\u0648\u0644\u0629 \u062c\u0646\u0627\u062d 385 127 \u0634\u0627\u0631\u0639 \u0627\u0644\u0639\u0634\u0631\u064a\u0646, \u0645\u0639\u0628\u0631 \u0639\u0628\u062f\u0627\u0644\u0644\u0647 Schlangenlaan 461a, Oost Jessamyingen, WV 8234 ZX 1 hoog Gritlaan 52, Margiesmeer, OK 1083 VE Java Kotlin Faker faker1 = new Faker ( new Locale ( \"nl\" )); Faker faker2 = new Faker ( new Locale ( \"ar\" )); List < Faker > fakers = Arrays . asList ( faker1 , faker2 ); for ( int i = 0 ; i < 10 ; i ++ ) { Faker randomFaker = new Faker (). options (). nextElement ( fakers ); System . out . println ( randomFaker . address (). fullAddress ()); } val faker1 = Faker ( Locale ( \"nl\" )) val faker2 = Faker ( Locale ( \"ar\" )) val fakers = listOf ( faker1 , faker2 ) repeat ( 10 ) { val randomFaker = Faker (). options (). nextElement ( fakers ) println ( randomFaker . address (). fullAddress ()) } Repeatable random results \u00b6 To generate a more predictable random result, it's possible to provide a seed value to the Faker. When providing a seed, the instantiatiton of Fake objects will always happen in a predictable way, which can be handy for generating results multiple times. Java Kotlin Faker faker = new Faker ( new Random ( 0 )); val faker = Faker ( Random ( 0 ))","title":"Usage"},{"location":"documentation/usage/#usage","text":"The simplest way to use Datafaker to generate fake data is by instantiating the Faker using the default constructor.","title":"Usage"},{"location":"documentation/usage/#default-usage","text":"Java Kotlin import net.datafaker.Faker ; Faker faker = new Faker (); String name = faker . name (). fullName (); // Miss Samanta Schmidt import net.datafaker.Faker val faker = Faker() val name = faker.name().fullName() // Miss Samanta Schmidt This will instantiate a Faker using the English locale.","title":"Default usage"},{"location":"documentation/usage/#different-locale","text":"To use Datafaker with a different locale, you can supply on in the constructor as such: Java Kotlin Faker faker = new Faker ( new Locale ( \"nl\" )); String name = faker . name (). fullName (); // Chelan Klijnsma val faker = Faker ( Locale ( \"nl\" )) val name = faker . name (). fullName () // Chelan Klijnsma","title":"Different locale"},{"location":"documentation/usage/#multiple-locales","text":"In case you want to mix locales, the easiest way to do so is to create a Faker per locale, and mix between those fakers. For an example, see below, which produce something like the following: 8708 \u0634\u0627\u0631\u0639 \u0642\u0637\u0631, \u0645\u062f\u064a\u0646\u0629 \u062e\u0648\u0644\u0629 \u062c\u0646\u0627\u062d 385 127 \u0634\u0627\u0631\u0639 \u0627\u0644\u0639\u0634\u0631\u064a\u0646, \u0645\u0639\u0628\u0631 \u0639\u0628\u062f\u0627\u0644\u0644\u0647 Schlangenlaan 461a, Oost Jessamyingen, WV 8234 ZX 1 hoog Gritlaan 52, Margiesmeer, OK 1083 VE Java Kotlin Faker faker1 = new Faker ( new Locale ( \"nl\" )); Faker faker2 = new Faker ( new Locale ( \"ar\" )); List < Faker > fakers = Arrays . asList ( faker1 , faker2 ); for ( int i = 0 ; i < 10 ; i ++ ) { Faker randomFaker = new Faker (). options (). nextElement ( fakers ); System . out . println ( randomFaker . address (). fullAddress ()); } val faker1 = Faker ( Locale ( \"nl\" )) val faker2 = Faker ( Locale ( \"ar\" )) val fakers = listOf ( faker1 , faker2 ) repeat ( 10 ) { val randomFaker = Faker (). options (). nextElement ( fakers ) println ( randomFaker . address (). fullAddress ()) }","title":"Multiple locales"},{"location":"documentation/usage/#repeatable-random-results","text":"To generate a more predictable random result, it's possible to provide a seed value to the Faker. When providing a seed, the instantiatiton of Fake objects will always happen in a predictable way, which can be handy for generating results multiple times. Java Kotlin Faker faker = new Faker ( new Random ( 0 )); val faker = Faker ( Random ( 0 ))","title":"Repeatable random results"},{"location":"releases/0.9.0/","text":"Datafaker 0.9.0 \u00b6 This release is a direct fork of Javafaker, with most of the more than 100 open PR's merged, and several other bugs fixed. Changes \u00b6 PR Description 692 Add Size (adjective) and Mood (feeling, emotion, tone) feature 685 Add random locale selection/rotation for internationalization/localization testing 603 683 IDEA: random java.time.Duration 677 682 Added cell phone support for the Dutch (NL) language. 680 Fix issue 668 676 I can see ar.yaml, Apparently you seem to support Arabic lang 675 Feature: Issue-666 673 US ZipCode should be specific about 5 or 5+4 digits (591) 672 add MG on state_abbr pt-br 596 659 (658) Fix typo in StarTrek species 656 Improve Travis CI build Performance 655 Shade snakeyml to avoid conflicts on consumers requiring higher versions 653 Removes trailing space in instrument name 650 Add es-PY.yml, based on es-MX.yml 645 Solving problem 414 644 Solve issue 450 643 Add Hearthstone feature 636 issue 571 635 Resident evil feature 633 Fix issue 391 Offer the possibility to generate a top and second level domain for a company 631 Fix issue 629 and issue 458 628 fix issue 626: Typo in the faker.subscription.plans variable inside es.yml 625 Add Minecraft and Touhou fakers 622 Fix bug 598 fake food ingredient has no support to hebrew 619 Fix issue 566 \"en-ZA\" ID number is invalid 617 Remove trailing space from animal name: turtle 616 Fix issue # 584: Internet.password doesn't always return expected value 614 Solve StarCraftTest Failed issue 611# 613 Fixed issue 584 606 Set country_code for NL.yml 604 Adds Portuguese VAT identification number (NIF) 602 Correctly handle generating a password of fixed length 595 Added hr locale support 594 ko.yml Faker Data Update 593 Changing the Turkish adage to its correct usage 583 Update ru.yml 582 Improve de-CH.yml 576 Added Dessert Faker 574 This PR fixes issue 568 (missing quote) 565 Fix russian translations 557 Update the IBAN code based on the latest version of iban_registry 511 Add some lastnames with \u00f1 for \"es\" and \"es-mx\" 509 Add some lastnames with \u00f1 for \"es\" and \"es-mx\" 506 Fiex testHungarianZipCodeByState() 499 Fixed Zh_CN IdNumber invalid issue 495 Added locale sensivity on longitute, latitude. 492 Complied regular expression patterns and applied some other performance suggestions 480 Vehicle Faker 462 Adding proper set of area codes for phone numbers in Canada for both 'ca' and 'en-CA' locales 453 add Science service and elementary particles 449 Add CS yaml 423 Babylon5 408 Fix inability to resolve dota.yml path. Add more dota heroes and items 387 Barcode generator 382 Fix german material names 354 Creates locale for es-AR 333 Update ru.yml 314 Add Singaporean ID numbers 264 Add CPF generation (identification number in Brazil like social security number)","title":"0.9.0"},{"location":"releases/0.9.0/#datafaker-090","text":"This release is a direct fork of Javafaker, with most of the more than 100 open PR's merged, and several other bugs fixed.","title":"Datafaker 0.9.0"},{"location":"releases/0.9.0/#changes","text":"PR Description 692 Add Size (adjective) and Mood (feeling, emotion, tone) feature 685 Add random locale selection/rotation for internationalization/localization testing 603 683 IDEA: random java.time.Duration 677 682 Added cell phone support for the Dutch (NL) language. 680 Fix issue 668 676 I can see ar.yaml, Apparently you seem to support Arabic lang 675 Feature: Issue-666 673 US ZipCode should be specific about 5 or 5+4 digits (591) 672 add MG on state_abbr pt-br 596 659 (658) Fix typo in StarTrek species 656 Improve Travis CI build Performance 655 Shade snakeyml to avoid conflicts on consumers requiring higher versions 653 Removes trailing space in instrument name 650 Add es-PY.yml, based on es-MX.yml 645 Solving problem 414 644 Solve issue 450 643 Add Hearthstone feature 636 issue 571 635 Resident evil feature 633 Fix issue 391 Offer the possibility to generate a top and second level domain for a company 631 Fix issue 629 and issue 458 628 fix issue 626: Typo in the faker.subscription.plans variable inside es.yml 625 Add Minecraft and Touhou fakers 622 Fix bug 598 fake food ingredient has no support to hebrew 619 Fix issue 566 \"en-ZA\" ID number is invalid 617 Remove trailing space from animal name: turtle 616 Fix issue # 584: Internet.password doesn't always return expected value 614 Solve StarCraftTest Failed issue 611# 613 Fixed issue 584 606 Set country_code for NL.yml 604 Adds Portuguese VAT identification number (NIF) 602 Correctly handle generating a password of fixed length 595 Added hr locale support 594 ko.yml Faker Data Update 593 Changing the Turkish adage to its correct usage 583 Update ru.yml 582 Improve de-CH.yml 576 Added Dessert Faker 574 This PR fixes issue 568 (missing quote) 565 Fix russian translations 557 Update the IBAN code based on the latest version of iban_registry 511 Add some lastnames with \u00f1 for \"es\" and \"es-mx\" 509 Add some lastnames with \u00f1 for \"es\" and \"es-mx\" 506 Fiex testHungarianZipCodeByState() 499 Fixed Zh_CN IdNumber invalid issue 495 Added locale sensivity on longitute, latitude. 492 Complied regular expression patterns and applied some other performance suggestions 480 Vehicle Faker 462 Adding proper set of area codes for phone numbers in Canada for both 'ca' and 'en-CA' locales 453 add Science service and elementary particles 449 Add CS yaml 423 Babylon5 408 Fix inability to resolve dota.yml path. Add more dota heroes and items 387 Barcode generator 382 Fix german material names 354 Creates locale for es-AR 333 Update ru.yml 314 Add Singaporean ID numbers 264 Add CPF generation (identification number in Brazil like social security number)","title":"Changes"},{"location":"releases/1.0.0/","text":"Datafaker 1.0.0 (03-01-2022) \u00b6 The first 1.x release! This release is backwards incompatible with previous versions since while the structure of the code is still the same, the package names have changed to net.datafaker . To migrate to this version of Datafaker, all you need to do is replace the imports from com.github.javafaker to net.datafaker . No other changes are needed. Notable changes \u00b6 Added ICD-10, ICD-10-AM, ICD-10-CM and ICD-10-PCS support to Medical Added Appliance provider Added Breaking Bad provider Added Bossa Nova provider Added RuPaul's Drag Race provider","title":"1.0.0"},{"location":"releases/1.0.0/#datafaker-100-03-01-2022","text":"The first 1.x release! This release is backwards incompatible with previous versions since while the structure of the code is still the same, the package names have changed to net.datafaker . To migrate to this version of Datafaker, all you need to do is replace the imports from com.github.javafaker to net.datafaker . No other changes are needed.","title":"Datafaker 1.0.0 (03-01-2022)"},{"location":"releases/1.0.0/#notable-changes","text":"Added ICD-10, ICD-10-AM, ICD-10-CM and ICD-10-PCS support to Medical Added Appliance provider Added Breaking Bad provider Added Bossa Nova provider Added RuPaul's Drag Race provider","title":"Notable changes"},{"location":"releases/1.1.0/","text":"Datafaker 1.1.0 (01-02-2022) \u00b6 Datafaker 1.1.0 reduces the number of external dependencies and provides a few minor bug fixes. It also includes a few internal improvements, mostly related to an improved level of code coverage. See for the full release notes below. Contributors \u00b6 For this release, we'd like thank Elton Andr\u00e9, Sergey Nuyanzin and Amit Solankurkar for their contributions to Datafaker. Notable changes \u00b6 Breaking (minor) change: Relationships has been renamed to Relationship . Bugfix: Fixed Russian translation ( PR #693 by Sergey Nuyanzin) Improvement: Added mountain ranges ( PR #696 by Sergey Nuyanzin) Improvement: Minimised external dependencies. Removed Guava and Apache Commons from production dependencies, and logging from test dependencies. Improvement: New examplify method in Faker, which generates a value by example, with the same pattern as the input value. (See the Javadoc for examples). PR #4 by Amit Solankurkar. Bugfix: Removed 226 area code as reported here Issue #698 . Improvement: Now supports valid Swedish (sv_SE) phone numbers based on Telephone Numbers in Sweden . Improvement: Now supports valid Dutch (nl_NL) phone numbers based on Telephone numbers in the Netherlands . Improvement: Now supports (mostly) valid Norwegian (nb_NO) phone numbers based on Telephone numbers in the Norway . Improvement: Now supports valid Czech Republic (cs_SZ) phone numbers based on Telephone numbers in the Czech Republic . Improvement: Now supports (mostly) valid Great Britain (en_UK) phone numbers based on Telephone numbers in the United Kingdom . Improvement: We now support Brazilian CPF and CNPJ numbers ( PR #5 ), thanks to Elton Andr\u00e9.","title":"1.1.0"},{"location":"releases/1.1.0/#datafaker-110-01-02-2022","text":"Datafaker 1.1.0 reduces the number of external dependencies and provides a few minor bug fixes. It also includes a few internal improvements, mostly related to an improved level of code coverage. See for the full release notes below.","title":"Datafaker 1.1.0 (01-02-2022)"},{"location":"releases/1.1.0/#contributors","text":"For this release, we'd like thank Elton Andr\u00e9, Sergey Nuyanzin and Amit Solankurkar for their contributions to Datafaker.","title":"Contributors"},{"location":"releases/1.1.0/#notable-changes","text":"Breaking (minor) change: Relationships has been renamed to Relationship . Bugfix: Fixed Russian translation ( PR #693 by Sergey Nuyanzin) Improvement: Added mountain ranges ( PR #696 by Sergey Nuyanzin) Improvement: Minimised external dependencies. Removed Guava and Apache Commons from production dependencies, and logging from test dependencies. Improvement: New examplify method in Faker, which generates a value by example, with the same pattern as the input value. (See the Javadoc for examples). PR #4 by Amit Solankurkar. Bugfix: Removed 226 area code as reported here Issue #698 . Improvement: Now supports valid Swedish (sv_SE) phone numbers based on Telephone Numbers in Sweden . Improvement: Now supports valid Dutch (nl_NL) phone numbers based on Telephone numbers in the Netherlands . Improvement: Now supports (mostly) valid Norwegian (nb_NO) phone numbers based on Telephone numbers in the Norway . Improvement: Now supports valid Czech Republic (cs_SZ) phone numbers based on Telephone numbers in the Czech Republic . Improvement: Now supports (mostly) valid Great Britain (en_UK) phone numbers based on Telephone numbers in the United Kingdom . Improvement: We now support Brazilian CPF and CNPJ numbers ( PR #5 ), thanks to Elton Andr\u00e9.","title":"Notable changes"},{"location":"releases/1.2.0/","text":"Datafaker 1.2.0 (05-03-2022) \u00b6 Contributors \u00b6 For this release, we'd like thank the following people: Sergey Nuyanzin for adding 90% of the features of this release. Sergey added support for file formats, custom fakers, speed improvements, and many, many other items. Alexandre Saudate for adding multi-branch CNPJ generation ( PR #71 ) David Ogar for contributing the Nigeria faker.( PR #70 ) zolv for adding add PESEL number generator ( PR #54 ) Marius Larsen for adding Formula 1 data ( PR #20 ) Valery Yatsynovich for changing AdoptJDK to Temurin ( PR #14 ) Koen de Bruijn for updating a code example in the usage documentation ( PR #6 ) To all of the above: we really appreciate all your contributions, and thank you all for making this library the way it is! Providers added \u00b6 In this release, more providers have been added: Australia The IT Crowd Marketing, mostly buzzwords for now Restaurant, with names, types, reviews, etc Nato Phonetic Alphabet Nigeria, thanks to David Ogar The CNPJ provider has been improved, and now supports multiple branches, thanks to Alexandre Saudate. For a complete list of providers, see the providers overview . Notable changes \u00b6 Improvement: Support for custom providers! Improvement: Support for CSV, XML, YML and JSON fileformat. Improvement: Support for specifying date formats for dates and timestamps. Improvement: Added nextInt and nextFloat methods to Faker to make the random() method a better Random replacement. Improvement: Added nextDouble and nextLong methods to Faker to generate random numbers between bounds. Add support of methods with varargs and #{options.option ...} ( PR #7 ), thanks to Sergey Nuyanzin. Fixes and several improvements in Datafaker dependency management ( PR #8 ) and ( PR #9 ), thanks to Sergey Nuyanzin. Added generation of ISO language and countries based on java Locale#getISOLanguages and Locale#getISOCountries ( PR #19 ) Many fixes and improvements in the build stability, lots of performance improvements and many fixes for flakey tests","title":"1.2.0"},{"location":"releases/1.2.0/#datafaker-120-05-03-2022","text":"","title":"Datafaker 1.2.0 (05-03-2022)"},{"location":"releases/1.2.0/#contributors","text":"For this release, we'd like thank the following people: Sergey Nuyanzin for adding 90% of the features of this release. Sergey added support for file formats, custom fakers, speed improvements, and many, many other items. Alexandre Saudate for adding multi-branch CNPJ generation ( PR #71 ) David Ogar for contributing the Nigeria faker.( PR #70 ) zolv for adding add PESEL number generator ( PR #54 ) Marius Larsen for adding Formula 1 data ( PR #20 ) Valery Yatsynovich for changing AdoptJDK to Temurin ( PR #14 ) Koen de Bruijn for updating a code example in the usage documentation ( PR #6 ) To all of the above: we really appreciate all your contributions, and thank you all for making this library the way it is!","title":"Contributors"},{"location":"releases/1.2.0/#providers-added","text":"In this release, more providers have been added: Australia The IT Crowd Marketing, mostly buzzwords for now Restaurant, with names, types, reviews, etc Nato Phonetic Alphabet Nigeria, thanks to David Ogar The CNPJ provider has been improved, and now supports multiple branches, thanks to Alexandre Saudate. For a complete list of providers, see the providers overview .","title":"Providers added"},{"location":"releases/1.2.0/#notable-changes","text":"Improvement: Support for custom providers! Improvement: Support for CSV, XML, YML and JSON fileformat. Improvement: Support for specifying date formats for dates and timestamps. Improvement: Added nextInt and nextFloat methods to Faker to make the random() method a better Random replacement. Improvement: Added nextDouble and nextLong methods to Faker to generate random numbers between bounds. Add support of methods with varargs and #{options.option ...} ( PR #7 ), thanks to Sergey Nuyanzin. Fixes and several improvements in Datafaker dependency management ( PR #8 ) and ( PR #9 ), thanks to Sergey Nuyanzin. Added generation of ISO language and countries based on java Locale#getISOLanguages and Locale#getISOCountries ( PR #19 ) Many fixes and improvements in the build stability, lots of performance improvements and many fixes for flakey tests","title":"Notable changes"},{"location":"releases/1.3.0/","text":"Datafaker 1.3.0 (2 April 2022) \u00b6 Another new release of Datafaker. We found out that in some cases, the 1.2.0 version of Datafaker is too aggressive with caching results. This version fixes that, so we'd advise all users to upgrade to 1.3.0. Also, this version contains many new features, such as many new providers, new APIs to work with JSON data, improved caching, and more. Contributors \u00b6 For this release, we'd like thank the following people: Sergey Nuyanzin again for adding most of the features of this release, such as nested JSON support, adding a Maven wrapper, enabling JDK 18 support, Alexandre Saudate for contributing the AWS faker! Very handy, thanks! Valery Yatsynovich for making the documentation just a bit better! Thanks! Julio Gutierrez for adding more caching to Datafaker. and Dependabot for keeping our dependencies up to date :) Providers added \u00b6 AWS Brooklyn Nine Nine Crypto Coin Hobby Horse Kpop Subscription Super Mario Volleyball Note: The Crypto provider has been renamed to Hashing, since they only contained one way Hashing functions. It can still be accessed using the crypto method, but this will be removed in one of the upcoming releases.","title":"1.3.0"},{"location":"releases/1.3.0/#datafaker-130-2-april-2022","text":"Another new release of Datafaker. We found out that in some cases, the 1.2.0 version of Datafaker is too aggressive with caching results. This version fixes that, so we'd advise all users to upgrade to 1.3.0. Also, this version contains many new features, such as many new providers, new APIs to work with JSON data, improved caching, and more.","title":"Datafaker 1.3.0 (2 April 2022)"},{"location":"releases/1.3.0/#contributors","text":"For this release, we'd like thank the following people: Sergey Nuyanzin again for adding most of the features of this release, such as nested JSON support, adding a Maven wrapper, enabling JDK 18 support, Alexandre Saudate for contributing the AWS faker! Very handy, thanks! Valery Yatsynovich for making the documentation just a bit better! Thanks! Julio Gutierrez for adding more caching to Datafaker. and Dependabot for keeping our dependencies up to date :)","title":"Contributors"},{"location":"releases/1.3.0/#providers-added","text":"AWS Brooklyn Nine Nine Crypto Coin Hobby Horse Kpop Subscription Super Mario Volleyball Note: The Crypto provider has been renamed to Hashing, since they only contained one way Hashing functions. It can still be accessed using the crypto method, but this will be removed in one of the upcoming releases.","title":"Providers added"},{"location":"releases/1.4.0/","text":"Datafaker 1.4.0 (20 May 2022) \u00b6 Thanks to the hard work of Sergey Nuyanzin and a lot of contributors, I'm pleased to say we have another new release of Datafaker. Lots of things have improved in this relase, such as (as usual), a lot of new providers, performance improvements in the generation of data, CSV and JSON generation through expressions, etc. Internally, we've recently migrated from JUnit 4 to JUnit 5, and from Hamcrest to AssertJ. This is a slightly better approach to testing to making sure our library is without any errors. Fun fact : at the moment, we have close to 30.000 tests, with a code coverage of around 93%. Despite having this amount of tests, all the tests run in less than 20 seconds! Contributors \u00b6 A big thanks to our contributes, without who this release wouldn't have been possible! Thanks to Tahanima for providing more fake data providers (Tea and Camera) Alexander Ilinykh for providing Philippino data Ilya Pantsyr for providing the Electrical Components provider Lance-Azrael for providing the Blood Type provider Izsak for providing the Oscar Movie provider Cooljj for providing the Battlefield 1 provider zhou mintao for providing the Soul Knight provider Providers added \u00b6 Battlefield 1 Blood Types Camera Device EldenRing Electrical Components Grateful Dead Hey Arnold Mountaineering Oscar Movie Seinfeld Soul Knight Tea Time Tron","title":"1.4.0"},{"location":"releases/1.4.0/#datafaker-140-20-may-2022","text":"Thanks to the hard work of Sergey Nuyanzin and a lot of contributors, I'm pleased to say we have another new release of Datafaker. Lots of things have improved in this relase, such as (as usual), a lot of new providers, performance improvements in the generation of data, CSV and JSON generation through expressions, etc. Internally, we've recently migrated from JUnit 4 to JUnit 5, and from Hamcrest to AssertJ. This is a slightly better approach to testing to making sure our library is without any errors. Fun fact : at the moment, we have close to 30.000 tests, with a code coverage of around 93%. Despite having this amount of tests, all the tests run in less than 20 seconds!","title":"Datafaker 1.4.0 (20 May 2022)"},{"location":"releases/1.4.0/#contributors","text":"A big thanks to our contributes, without who this release wouldn't have been possible! Thanks to Tahanima for providing more fake data providers (Tea and Camera) Alexander Ilinykh for providing Philippino data Ilya Pantsyr for providing the Electrical Components provider Lance-Azrael for providing the Blood Type provider Izsak for providing the Oscar Movie provider Cooljj for providing the Battlefield 1 provider zhou mintao for providing the Soul Knight provider","title":"Contributors"},{"location":"releases/1.4.0/#providers-added","text":"Battlefield 1 Blood Types Camera Device EldenRing Electrical Components Grateful Dead Hey Arnold Mountaineering Oscar Movie Seinfeld Soul Knight Tea Time Tron","title":"Providers added"},{"location":"releases/1.5.0/","text":"Datafaker 1.5.0 (25 July 2022) \u00b6 A little later than expected, but well worth the wait: another release of Datafaker, improved generation of phone numbers, 20(!) new providers, and many small improvements. Thanks everyone for supporting this library! Contributors \u00b6 A big thanks to our contributes, without who this release wouldn't have been possible! Big shouts out to: Sergejs Visockis Ilya Pantsyr Iago Saito Tahanima Chowdhury A special shoutout to Ilya, who did so many PR's that we had no other choice to make him part of the team! Welcome Ilya! Providers added \u00b6 Big Bang Theory Cannabis Coffee Dark Soul DC Comics Departed Driving License Famous Last Words Ghost Busters Greek Philosopher Hololive House Football Industry Segments MBTI (Myers-Briggs Type Indicator) Measurement Money Movie Simpsons Verb","title":"1.5.0"},{"location":"releases/1.5.0/#datafaker-150-25-july-2022","text":"A little later than expected, but well worth the wait: another release of Datafaker, improved generation of phone numbers, 20(!) new providers, and many small improvements. Thanks everyone for supporting this library!","title":"Datafaker 1.5.0 (25 July 2022)"},{"location":"releases/1.5.0/#contributors","text":"A big thanks to our contributes, without who this release wouldn't have been possible! Big shouts out to: Sergejs Visockis Ilya Pantsyr Iago Saito Tahanima Chowdhury A special shoutout to Ilya, who did so many PR's that we had no other choice to make him part of the team! Welcome Ilya!","title":"Contributors"},{"location":"releases/1.5.0/#providers-added","text":"Big Bang Theory Cannabis Coffee Dark Soul DC Comics Departed Driving License Famous Last Words Ghost Busters Greek Philosopher Hololive House Football Industry Segments MBTI (Myers-Briggs Type Indicator) Measurement Money Movie Simpsons Verb","title":"Providers added"},{"location":"releases/1.6.0-SNAPSHOT/","text":"Datafaker 1.6.0 (SNAPSHOT) \u00b6 Contributors \u00b6 Providers added \u00b6","title":"1.6.0-SNAPSHOT"},{"location":"releases/1.6.0-SNAPSHOT/#datafaker-160-snapshot","text":"","title":"Datafaker 1.6.0 (SNAPSHOT)"},{"location":"releases/1.6.0-SNAPSHOT/#contributors","text":"","title":"Contributors"},{"location":"releases/1.6.0-SNAPSHOT/#providers-added","text":"","title":"Providers added"}]}